# Trading procedure (Traveller 77 Book 2 pp. 42-4)
#
# Once per week, throw d66 to determine best cargo
#   DMs per world population
# Determine quantity
# Purchase if desired, up to limits of quantity
#   and available cargo space
# Partial purchases incur 1% fee
# Determine price of goods by 2d6 roll on table
#   DMs per skills, brokers, world characteristics
#
# Can sell cargo on a (different?) world
# Sale price by 2d6 roll on table
#   DMs per skills, brokers, world characteristics

# So overall sequence would be:
# Enter trade depot and see available goods
# Choice: wait a week, purchase some or all, jump to new system
# (And at any point can sell cargo in the hold)

# Other elements we will need:
#   time/calendar (so we will want to display current time...)
#   world characteristics
#   cargo tables
#   bank account (also need to display/query this...)
#   brokers for hire
#   character skills
#
# Not covered in this section, but eventually will want
# starship economics (Book 2 pp. 5-8)
# Operating expenses:
#   fuel
#   life support
#   routine maintenance
#   crew salaries
#   berthing costs
#   bank payment
#
# The starship economics section also covers freight
# shipping (flat rate - above is speculation) - add
# this option eventually. Also passengers.

# Ship design and customization is another potential
# area to explore. We'll assume a simple standard design
# (like the Free Trader) to start with.

# The star map will be a whole 'nother thing. A couple
# potential approaches:
#   Traveller subsector maps, whether generated or
#     loaded from a file
#   On-demand world generation - of course will need
#     to persist these systems as they are created

# UI thoughts:
#  as long as we're text-based, might want to play with
#  more ANSI code formatting to distinguish various things
#
#  also think about persistent display sections, rather than
#  always having to query data points
#
#  will need to make all the input much more robust - it needs
#  to handle bogus input appropriately

# -------------------------------------------------------------
# Comments about individual cargo unit_size assessment, prune
# through this and retain if any is useful...
# ---------------------------------------------------
# This data might belong in the cargo tables rather than here
# also, the RAW is very handwavy about tonnage for individual items,
# basically says "figure it out" - only some of these items
# are in the equipment list, so I'll fill in something plausible
# as best I can
# 
# Equipment list comparisons drawn from Book 3 (pp.16-7)
#
# Also need to consider that tonnage should be _displacement tons_
# not mass, so fiddle with the numbers supplied as necessary
# and there's packing material to consider too, as they call out in
# the example on Book 2 p. 43
#
# Per Traders & Gunboats p. 5, a 1.5m deck plan square, floor to
# ceiling, is half a displacement ton - so a 100-ton ship has
# 200 grid squares in theory. Yes, cargo hold ceilings might be
# higher than 3m, but this is a good enough basis for converting
# length/width into displacement numbers.
#
# Of course if we're dipping into sources later than the original
# three LBB, then we should be able to look all this up directly.
#
# Another observation - Traveller 77 trading setup does not consider
# Tech Level at all. Some of the items below might not be 
# producible on a given (low-tech) world. Can hand-wave by 
# assuming they are off-world products being warehoused here...
# 
# We'll assume the aircraft are less dense than the ground vehicles
# and fiddle with mass to volume ratios accordingly
#
# assume TL5 Fixed Wing Aircraft based on price
# weight 5 tons, cargo 5 tons, length 15m, wingspan 15m

# assume TL8 Air/Raft based on price
# weight 4 tons, cargo 4 tons
# the Scout/Courier deck plans in Traderes & Gunboats
# allocates 12 grid squares to its Air/Raft, so 6 d-tons

# not listed - base this on ship's computers
# closest fit is the Model/2bis, which costs a bit more
# (12MCr vs 10), and displaces 2 tons

# assume TL6 All Terrain Vehicle based on price
# weight 10 tons

# assume TL6 Armored Fighting Vehicle based on price
# weight 10 tons

# not listed, will need to guesstimate
# let's just assign it the same stats as ATV/AFV
# -------------------------------------------------------------

# -------------------------------------------------------------
# I'd like to ease the remaining coupling, don't like passing objects
# in to all the ctors, everything has access to everything. It's better
# than the previous global resource abuse, but could be better.
#
# The model I arrived at in Ship.refuel() may provide the way. It 
# handles its own data, then passes back the cost to the caller, which
# then passes it along to Financials. If we allow multi-dimensional
# costs (money, time, fuel, space), then the component classes could
# be properly ignorant of one another. Only the master Game class
# (which holds references to everything already) would know. This is
# something like a service bus - a blob of data flowing down a pipe,
# with individual components choosing whether to take action or not.
#
# Calendar (ImperialDate)
# ImperialDate
# Cargo (Credits)
# CargoDepot (Cargo, ImperialDate, Credits, Financials, Ship, StarSystem)
# Financials (Credits, ImperialDate, Ship, StarSystem)
# Credits
# Ship (Credits)
# StarSystem (Ship, Financials, CargoDepot)
#
# Should distinguish importing a class vs. calling methods or
# accessing fields on an existing object. The former is OK, the
# latter is coupling.
#
# The data classes (ImperialDate, Credits, Cargo) are fine, and
# right now Ship and StarSystem (with a minor exception) are in
# the same category. StarSystem owns CargoDepot - otherwise it
# is not coupled at all, so moving the latter up seems like a 
# good move.
#
# Almost all the logic outside of the master Game class is in
# CargoDepot, Financials, and Calendar. Those are the focus.
#
# So, after some initial shuffling, we now have:
#
# [OK] ImperialDate
# [OK] Calendar (ImperialDate)
# [OK] Cargo
# [  ] CargoDepot (Cargo, ImperialDate, Credits, Financials, Ship, StarSystem)
# [OK] Credits
# [  ] Financials (Credits, ImperialDate, Ship, StarSystem)
# [OK] Ship (Credits)
# [OK] StarSystem
#
# So, the model I think we're striving for is all actions involve
# invoking a series of sub-actions which return multi-dimensional
# costs, then passing the costs to the payees. Tempting to create
# a little class to represent costs, but that's overengineered at
# this point. Keep it to a simple tuple until we need more.
#
# Current actions:
#   quit
#   list commands
#   cargo hold contents
#   view world characteristics
#   wait a week
#   lift off to orbit
#   trade
#   refuel
#   go to jump point
#   land on surface
#   jump to new system
#   inbound to orbit
#   leave trade
#   show goods for sale
#   buy cargo
#   sell cargo
#
# There will of course be others, like skimming fuel, but these
# give a good sampling of what to expect. A few types:
#
# State transitions (quit, lift off, go to jump, land, jump, inbound, trade, leave)
#     Change state on object, may have a time cost
# Informational (list commands, hold contents, world chars., show goods)
#     Pull information from object
# Actions (wait, refuel, buy, sell)
#     Interact with objects, may have multiple costs
#
# These distinctions are pretty arbitrary, at least between the first
# and third. And in some ways even the second if you allow zero-cost as
# a thing. Anyway.
#
# So next step might be to make all actions (Command objects) correspond
# to a method on Game, and not allow them direct access to the child
# objects. Most pressing for buy/sell, but even the simple informationals
# should comply.
#
# Separating the child classes from interface actions (like print
# in the current UI paradigm) is also probably a good thing. They don't 
# need to know whether their output goes to the console or a
# GUI window. Be cautious of YAGNI of course. But still, if this is
# something like MVC, then the child objects are MODEL and shouldn't
# display anything at all.
#
# There are separate issues for the two classes still needing decoupling.
# CargoDepot is coupled in buy/sell cargo, which are both very long methods.
# Financials is coupled in notify and the tasks it calls.
#
# For the former, should break up the methods into small pieces (that
# still live in CargoDepot), then move the orchestration logic up to
# Game.
#
# For the latter, lift the observer up to Game - just add this logic in
# wait_week. At that point we only have one observer so the entire thing
# may not justify its existence, even though it isn't causing any problems
# in CargoDepot.
#
# OK. CargoDepot buy & sell have been broken up, and lifted into
# Game. This opens the door to removing references to Ship &
# Financials and fully decoupling the class. Methods of course will
# continue to slide around to appropriate homes as we go, but for now
# this is pretty clean. (I _do_ envision some sort of split of Game
# itself, possibly along MVC lines. We may end up pulling too many
# things up and that class will become bloated. One step at a time.)
# -------------------------------------------------------------

# -------------------------------------------------------------
# Another question is how to handle per-trip fuel costs.
# One model is to assess a cost for travel out to the
# jump point, and again for inbound. That does leave open
# the possibility of the ship being stranded.
# Alternative would be to assess the full trip cost on 
# landing.
# In both cases, there's the question of the player gaming
# the system and either evading costs or getting stuck.
#
# Could add a check before outbound to jump point that the ship
# has at least 2x cost (for there and back).
# -------------------------------------------------------------

# -------------------------------------------------------------
# We'll use the standard Imperial calendar, though that didn't
# yet exist in Traveller '77
# year is 365 consecutively numbered days
# date displayed as DDD-YYYY
# seven day weeks and four week months are used to refer to
# lengths of time, but rarely to establish dates
# (of course fun math, 7 * 4 * 12 = 336, so we are missing
# 29 days - but since week/month are really just durations
# it shouldn't matter)

# right now we only have refreshing the cargo depot weekly as an
# event, but there will be more:
#    * monthly loan payment
#    * annual maintenance
#    * monthly crew salaries
#    * daily berthing fees for extended stays
# other operational costs might better be handled as resource modeling:
#    * fuel
#    * life support

# also need to advance the calendar while in-system
# RAW says that ships typically take two trips per month:
# each jump is one week, and they spend a week buying & selling
# cargo, finding passengers, and on shore leave

# two approaches:
#    * give each action a cost in days
#    * advance the calendar only on jump and liftoff (the latter
#        perhaps with a message like 'you spent a week on Yorbund')

# for the former, does it add up to about a week? and do we want the
# player to be fiddling with time as well as money and space?
#    * to/from jump point - 1 day each
#    * to/from orbit - no time, don't want to privilege highport
#    * buy cargo (and load into ship) - 1 day
#    * sell cargo (and load into ship) - 1 day
#    * find passengers (and embark) - 1 day
#    * find freight (and load into ship) - 1 day
#    * listing hold/depot contents - no time
#    * refuelling - no time at port, 1 day to skim 
#    * recharging life support?
#    * financial transactions - no time
#
# easily 6-7 days if the player does all activities
# but if they want to go fast, jump in, skim fuel, jump out - just
# one day? or even no delay if they have reserve fuel.
#
# Alright. I think I'll add time costs per the schedule above, and
# see how it plays. We're applying costs in the action methods in
# Game, so this should go there as well.
# -------------------------------------------------------------

# -------------------------------------------------------------
# Will want to consider what aspects of the starport to bring into
# play. Fuel availability for sure, as well as maintenance
# availability. Need to mull over minor damage and whether other
# repair facilities should be accounted for. Bases? Probably easy
# to add, have no real play effect, just color (could influence
# ship encounters, but even those are mostly color at least in the
# initial version). Ship construction is also for some future 
# version, if ever.
#
# Interesting that starport has no impact on trade. You'd think
# that an E or X class at least has minimal to no cargo available.
# But let's not critique the system just yet. I'll fill in ambiguous
# areas as needed, but otherwise keep to RAW. Later maybe we'll
# explore other editions and/or homebrew our own trading rules.
# -------------------------------------------------------------

# -------------------------------------------------------------
# Sketching out annual maintenance procedure.
# Book 2 p. 6
# Annually, a starship should be given a complete overhaul...
# Such maintenance costs 0.1% (1/1000th) of the cash price of the 
# ship, and requires two weeks at a class A or B starport...
# Crew members generally take their vacation at this time, but 
# must still be paid. Provision should also be made for the 
# expected loss of revenue while the ship is out of service.
#
# So, I think to start with, we flag the ship with a 'last 
# maintenance date' - use the start point of that two week
# period.
#
# Then we should be able to calculate 'days since last 
# maintenance.' This function will need to know ship maintenance
# date as well as current date. Model we use in Financials
# for other expenses (invoked from Game) ought to work.
# 
# May want to report on maintenance age, at least when it starts
# approaching a year. (Exact date ought to be visible all the 
# time from ship details.) Something like:
#  GREEN - maintenance less than 10 months ago - don't report
#  YELLOW - maintenance 10-12 months ago
#  RED - maintenance more than 12 months ago
#
# Financials already has a reference to ship that I have not
# refactored away. Intended to do that, so adding the method
# there is a bit backward, but whatever model we decide to 
# decouple will apply here too, so no real harm. (There is some
# logic to tightly binding Financials and Ship as well, so
# perhaps one should own the other. Later refactorings will help
# suss this out.)
#
# At least two mechanisms from there:
#  * if maintenance status is RED, there is a chance of drive
#    failures and/or misjumps (Book 2 p. 4)
#  * we'll need a 'perform maintenance' action at starports, which
#    advances the calendar two weeks, charges the appropriate cost,
#    and resets the maintenance date on the ship. Since it can
#    only be performed at class A/B starports, would be nice to
#    have this command dynamically available, but if not, it should
#    block at inferior sites.
#
# Beyond that, if we want to get fancy, would be nice to provide
# some assists to the player. They will want to know how far the
# closest A/B starports are, and gauge travel times.
# -------------------------------------------------------------

# -------------------------------------------------------------
# Reviewing the calendar observers. There are a couple goals:
# * Financials is coupled to Ship and StarSystem in notify. If
#   we remove or lift that, we'll only have one observer, so
#   the entire pattern is in question here. It may be 
#   over-engineered for the actual use case.
# * Feature-wise, we need to make sure that repeating events
#   (which is pretty much all we have) execute multiple times
#   if the duration is long enough. That doesn't seem to be
#   the case with the current implementation, though it's 
#   tricky to tease out. Maybe a mock observer and test case
#   to help peel it apart? But the solution may need to be
#   in the observer with current, because they know their
#   date and frequency.
#
# Observer test scaffolding is in place, so we can play around
# with this. But also, on reviewing, Calendar doesn't have a
# very clear reason for existing. It holds an ImperialDate, and
# a list of observers that it notifies upon change. Some of its
# logic duplicates functionality already in ImperialDate. And if
# we lift up the observer stuff to Game, there's not much here.
#
# Conceptually, a Calendar ought to hold _multiple_ dates, right?
# That's what makes it different from just a date. I think I was
# initially heading in that direction. So, whatever blob of code
# holds the observers should probably also hold their dates. Or
# to put another way, when an observer registers, it ought to 
# register the date that it cares about (or schedule? or 
# frequency?). That would bring the logic that decides how to
# fire actions in scope here, and not scattered across all the
# observer classes (we only have two right now, but anyway).
#
# Components of a schedule:
# * notification date
# * due date
# * recurrence
#
# Current (bugged) logic:
# 1) if notification date is later than due date, execute action
# 2) set next due date to last due date plus recurrence
#
# Should have a 'step 1.5' which is to calculate how many times
# to execute the action, based on the duration between notification
# and due dates. Financials.renew_berth() does that (though I'm not
# 100% sure it is fully correct; there's some odd 'renew for 6, renew
# for 1' behavior going on).
#
# Ah! Think I just spotted the bug in Financials...
# 
# OK. Fixed. But also, I now think 'due date' is mistaken. We should
# have 'paid up date' (whatever concise name should go here...). And
# due date is actually every _recurrence_ thereafter. These types of
# events, we're not providing an option to pay early, so they will
# always be on predictible days in the future. So calculate an integer
# division (_not_ modulus) and set the paid date to the last such, 
# and move on.
#
# I was able to test drive this design, and it looks correct so 
# far. Only problem is that the interesting code lives in my mock
# observer, not in calendar. So to implement for real, I need to 
# apply this design to all of the existing observers. And though
# there's only two subscribed classes, in some ways each event is
# one. Potentially worth extracting into a class. We will see.
#
# Almost done with this work. Turns out there are slight variations
# in the model. Also Financials is riddled with side effects that
# I will need to address, so while the tests work and helped to drive
# the code to a better state, I will mark them skip for now.
#
# We have a total of five observer events to deal with:
#  1) CargoDepot.notify() - to refresh cargo selection weekly.
#      Refreshes cargo weekly, but doesn't need to execute
#      multiple times, just once if duration has passed.
#  2) Financials.berth_notification() 
#      Two phases: first part on landing, with six-day coverage.
#                  then a daily renewal after that.
#  3) Financials.salary_notification()
#      Standard observer model with a 28 day recurrence.
#  4) Financials.loan_notification()
#      Standard observer model with a 28 day recurrence.
#  5) Financials.maintenace_notification()
#      No recurrence. Just calculates a duration and reports
#      status. Resetting the state is via a separate mechanism.
#
# The 'standard observer model' is:
#  Observer:paid_date
#  Observer:recurrence
#  Observer:notify(date)
#      duration = (date - paid_date) // recurrence
#      for i in range(duration):
#          execute_action
#          paid_date += recurrence
#
# All done with the initial set of tests. Need to review to make
# sure the date ranges chosen make sense - though the tests are
# passing, I'm not 100% certain I chose good boundary values. Also,
# might not have emphasized the whole 'repeat on long ranges' thing.
# Still, scaffolding in place for improvements.
# -------------------------------------------------------------

# -------------------------------------------------------------
# Working through the design for multiple star systems. A few
# considerations:
#
# * Basics. Traveller maps the universe on a 2D hex grid. One
#   hex is one parsec, with each hex either being empty or 
#   occupied by a single star system. In Traveller '77 these
#   are very rudimentary, with no stellar characteristics and
#   only the 'mainworld' described at all. The standard map
#   is an 8 hex by 10 hex subsector (all that exists in '77) - 
#   later these were grouped into larger sectors (4x4 subsectors).
#
#   At least for the intial version(s), I will maintain the 2D 
#   hex grid standard.
#
# * Coordinate system. To distinguish different star systems, and
#   to calculate distances between them, we need some kind of 
#   coordinates. The standard Traveller subsector assigns each
#   hex a row/column coordinate - so they run from 0101 through 
#   0810. In the expanded sector arrangement, they run from 0101
#   through 3240.
#
#   But these coordinates can be a PITA to work with for anything
#   but simple layout. Calculating distances between two arbitrary
#   hexes is rough, and you need a second square (well, rectangular)
#   grid coordinate overlaying it to handle crossing subsector
#   boundaries.
#
#   In a previous project, I came up with a three-axis system that
#   works pretty well. Distances are trivial to calculate (the 
#   highest absolute value of any of the three coordinates). There's
#   also an interesting checksum built in - if the coordinate is
#   valid, its three values sum to zero.
#
#   Expanding on that, I had considered a 'circular grid.' Rather 
#   than arbitrary subsector boundaries overlain on the universe,
#   each world can effectively be the center of its own subsector.
#   Some products used to publish 'jump maps' that take this view,
#   like all hexes within 4 parsecs of some central world.
#
#   But again, the goal for this first version is compatiblity with
#   Traveller '77 RAW, so we should use the three-axis system
#   internally, with conversion to the standard row/column format for
#   display. My previous project already worked out the math, so we
#   can lift it.
#
# * Canon. Touched on above already. I don't mean canon in terms of 
#   setting. Traveller '77 doesn't have one, which is part of its
#   charm (though a bit is implied by things like Credits, naval 
#   bases, and so on, the Imperium is never mentioned).
#
#   I more mean 'rules canon.' As great as Traveller is, there's some
#   very clunky or outdated ideas in there too. And it is mighty 
#   tempting to 'fix' them.
#
#   For now, resist the tempation. I could see a future version
#   of this (or a spinoff) going in a different direction. The round
#   grid mentioned above is one idea (or a 3D grid). Lots of drift
#   to be found in later Traveller editions, especially in world
#   building and astrophysics. And I have some ideas about how 
#   interstellar cultures could work too. But all that is later.
#   Stick to RAW.
#
# * Dynamic generation. OK, this is finally getting into _how_
#   we're going to implement this feature. There are a couple 
#   basic approaches I can see:
#
#   * Dynamically generate star systems on the fly as we need 
#     them. Of course we also want persistence, so once 
#     generated we need to be able to get them back. And 
#     persistence across game sessions is a consideration
#     too - is the universe gone once you quit, or can you
#     resume play in it? I think eventually I'd want the latter,
#     though we could defer until later.
#
#   * Have a pregenerated map to work from. In practice, I would
#     probably generate the map rather than just enter in the data
#     from a published source. (Though the latter has some appeal
#     too - tooling around in the Spinward Marches would be fun.)
#
#   I think dynamic will be simpler to get working. Most of the 
#   pieces built there will also be useful for map generation.
#   And once we get persistent saved games, that will help us
#   figure out file formats and so on for the data entry
#   approach.
#
# * Coding strategy. All that said, still not sure exactly how
#   to tackle. Tempting to sketch out a bunch of classes and
#   so on. But probably better to work from in-game use cases.
#   That's been the approach so far, and it seems good. As with
#   test driven design, each next step is small and pretty 
#   obvious, even when you don't quite know where things will 
#   end up.
#
#   So let's start from the 'jump' action in Game. Figure out
#   what's needed there, and build out piece by piece.
#
#   * We need fuel & life support costs, jump range, and time.
#     All that is in place already.
#
#   * If the ship qualifies (enough fuel/support, and at the 
#     jump point), show all systems in range. At jump-1, that's
#     at most six.
#
#   * For the initial bring up, we can have a stub that just
#     returns a single system. And it should be able to swap
#     back and forth between that and our original world.
#
#   * The new star system can be mock data added by hand. 
#     Later we'll have some facility for generating a new
#     world, or looking it up on the internal map.
#
#   * Player selects destination, confirm and go!
# 
#   * Any global references that are tied to location
#     need to be fixed up. Already have some comments about
#     the observers and the command set in the traveller
#     module; wouldn't be surprised if there are others.
#
#   * Last, now that we finally have a reasonably comprehensive
#     set of unit tests and good-ish hygiene, the new classes
#     should be developed test first as much as possible, and
#     conform to pylint feedback too.
#
# * Beyond that initial feature, we'll definitely want:
#
#   * Ability to see the star map somehow. Might be interesting
#     in a text interface... Optionally being able to render
#     out as a bitmap might be cool. Also need associated 
#     UI actions.
#
#   * Hints for the player about things like nearest maintenance
#     depot, where frontier fuelling is available, etc.
#
#   * Of course save/load of star map data, as mentioned above.
#     (And UI actions...)
#
#   * Things like misjumps need to be considered. In some ways
#     very easy if we assume three-axis coordinates and dynamically
#     generated universe.
#
# OK, after all that, I almost immediately went off course. It's
# obvious we'll need some kind of map class to manage all the 
# systems. So I made a StarMap class. And from there, I started
# some simple tests to drive a basic interface. And that's 
# ballooning a bit. The strategy above assumed more of a mock
# StarMap that would only allow us to bounce between two
# hard-coded systems, but I'm building something more 
# full-featured (though still pretty simple).
#
# Questions we'll need to address (more of them):
#
# * Container for star systems. Very straightforward, and on
#   its own not enough to justify a class. I'll use a dictionary
#   with the key being a coordinate tuple. Tempting to make
#   another little class for coordinates, but premature I think.
#
# * Coordinate system and 'space.' We need to be able to distinguish
#   separate star systems, to calculate distance between them, and
#   so on. Per the above, coordinate system will be three-axis. My
#   test driving right now is building up that functionality.
#
# * Travel basics. This is the section above. We can hard-code
#   a map of just two systems and then build up travel mechanics
#   until they're set.
#
# * Populating the map. Once that is all working satisfactorily,
#   we'll need to decide how to fill in the map. Since we want
#   dynamic, this will be a JIT system. Request a system by 
#   coordinate. If it's in the container, return it. If not,
#   generate it.
#
# * Generation of star systems. Finally, we'll need to be able
#   to create new systems on the fly. Initially we'll just have
#   hard-coded values, but will need to create for real 
#   eventually. Traveller world generation procedures are 
#   easy to implement, so not a big deal. World name generation
#   may be the most interesting part.
#   
# First two above are basically done. May be tweaks later, of
# course. Time to work on travel mechanics.
#
# Travel is working! We can finally move between systems and
# trade goods. The basic game flow is working. Lots of polish
# and little features to add from here, of course. I want to do
# a little more testing and handle some rough edges spotted
# during playtest, then we'll get the JIT generation up and running.
#
# For JIT, we need a few things:
#
# * First, the methods in StarMap need to accommodate a 'None'
#   entry in the system dictionary.
#
# * Second, we need to be able to calculate coordinates relative
#   to an origin. We can handle distances, but generating new
#   coordinates, not quite yet. One approach is to handle
#   as a set of translates - for example, extending the axial
#   rows is as simple as repeatedly adding the appropriate
#   edge hex from the first ring. And the hexes in-between are
#   a combination of translates along two axes.
#
#   Another observation is there are axis rows, and six 'pie
#   slices'. At a given range, there are exactly six axis hexes,
#   and (range-1)*6 edge hexes.
#
#   And another - if you look at a diagram and figure out a 
#   given edge hex's coordinate (axis hexes are trivial), stepping 
#   along the two axis rows that bound its slice and adding those
#   two axis hexes together gives the result, just like with
#   Cartesian coordinates. So you just need to keep track of
#   which two axes govern that slice. (And of course adding
#   two coordinates together is basic vector translation...)
#
#   I have this working for everything except the edge hexes. Need
#   to work out the formula. But another idea occurred to me. What
#   if we just create the full set of potential hexes based on range,
#   then eliminate the invalid ones? Tempted to do this and see
#   which is more performant. I think this new idea would be less
#   code at a minimum, and probably easier to comprehend, than 
#   some geometry-based logic.
#
#   As it turns out, the list comprehension approach was very
#   easy to build and verify. And certainly less code overall.
#   Probably more readable to as long as you're comfortable with
#   the syntax. I stripped out all the geometry-calculating
#   methods. Maybe sometime it would be interesting to figure
#   out, and I suppose there's a theoretical performance
#   question to understand, but at the scale this program is
#   working, I don't think it's meaningful. I hope. Stress test 
#   with a _really_ big map? What's the big-O for my algorithm?
#   There is a cube of range involved in get_all_coords(),
#   which makes me a bit leery. We probably only ever run
#   it with small numbers. Jump-6 is the maximum in Traveller,
#   and a reasonable maximum for grabbing a bunch of coordinates
#   all at once. We'll keep an eye on performance and see.
#
# * That done, the last bit is easy: get_systems_within_range()
#   should look at all hexes by coordinate, not by what is present
#   in the dictionary. An if a given coordinate is not in the 
#   dictionary yet, generate it. The result will be either
#   None or a StarSystem.
#
# All this is working. The map is effectively infinite, with 
# new systems being added around the edges as needed. Right 
# now they're all hard-coded to a test value. Need to create
# some kind of factory to build them. But it works!
#
# I did a bit more validation, and some manual testing flying
# around this little galaxy. It pushed me to implement some
# better visibility into the map, so coordinates are now shown
# when printing StarSystems, and we have a command to dump out
# the entire map at will. It is persistent within a session - 
# I can travel across the map and back, and still see the same
# (generated) systems in the same places. On to world factory.
# -------------------------------------------------------------

# -------------------------------------------------------------
# ROADMAP
# Mulling over how to tackle ever-increasing TO_DO list.
# I think we can chunk the work into a few phases:
#  PHASE ONE
#  * Full feature set for in-system speculative trading. Just a few
#    maintenance costs left to go.
#  * Basic travel & resources features.
#  * Refactoring. In the midst of a big push right now.
#  * (Should really take my medicine and get tests/pylint/etc. done)
#  PHASE TWO <== we are here
#  * Jumping to a new system and all it implies:
#    * Multiple systems
#    * Star map
#    * Coordinate system
#  PHASE THREE
#  * Adding freight & passengers
#  * Any other remaining RAW procedures:
#    * crew, misjumps, etc.
#  PHASE FOUR
#  * Polishing game mechanisms:
#    * UI work
#    * Front end and menu
#    * Save/load if not done earlier
#    * Player customization: ship name, captain, etc.
#    * Save/load
#  PHASE FIVE
#    * Expand scope with RPG-lite elements and events
#    * Lift into graphics system? (This could really snowball, be cautious)
#    * Explore later Traveller versions for ideas (or to support as options)
# -------------------------------------------------------------

# --------------------------------------------------------------
# Consolidating TO_DO list:

#  PHASE ONE =======================================================
#  * [DONE] Create a currency class to keep value vs. display straight
#  * [DONE] Deprecate and remove credit_string() function
#  * [DONE] Add (basic) math/comparison operators to currency class
#            (add more operators as needed)
#  * [DONE] Change purchase/sale DMs from lists to hashes to improve data
#            entry and validation
#  * [DONE] Regenerate cargo for sale weekly (and reset price adjustment)
#  * [DONE] Review Calendar increment scenarios, remove speculative options
#  * [DONE] Add 'wait a week' command
#  * [DONE] Add extended berthing fee mechanism
#  * [DONE] Add monthly loan payment
#  * [DONE] Add monthly crew salaries
#  * [DONE] Protect input from bad data - one example, non-numeric
#            values cause crashes
#  * [DONE] Extract confirmation input loop to a reusable function
#  * [DONE] Display current date
#  * [DONE] Add fuel system to Ship
#  * [DONE] Add refuelling costs at starport
#  * [DONE] Restructure payment flow & dependencies for fuel
#  * [DONE] Add starport classification to StarSystem
#  * [DONE] Pass Credits in to Cargo ctor, not integer that needs conversion
#  * [DONE] Add fuel level check before executing jump
#  * [DONE] Add gas giant presence to StarSystem
#  * [DONE] Add view StarSystem data action
#  * [DONE] Skimming as jump point action, assuming gas giants present in 
#            StarSystem (abstract the outer system for this purpose)
#  * [DONE] Add 'plus days' method to ImperialDate (went with dunder again)
#  * [DONE] Create an unload_cargo method to consolidate proper handling
#  * [DONE] Add crew skills and their influence on sale prices
#  * [DONE] Add brokers and their influence on sale prices
#  * [DONE] Add display of ship characteristics
#  * [DONE] Prevent immediate resale of bought cargo
#            (current solution just prevents sale to source world, may want
#             to add a time element - simplest would be to reset the source_world
#             field to None, but later for Merchant Prince we may want to retain it)
#  * [DONE] Separate code out into modules
#  * [DONE] Review interpretation that skills/brokers only apply to sales - yes
#  * [DONE] Review Calendar.year() setter for whether it should notify observers - yes
#  * [DONE] Make StarSystem.__eq__ more robust
#  * [DONE] Add ship streamlining and effect upon landing/skimming
#  * [DONE] Add life support system to Ship
#  * [DONE] Add life support recharging costs
#  * [DONE] Check life support level before jump
#  * [DONE] Add fuel level check before travelling to jump point
#  * [DONE] Add life support expenditure
#  * [DONE] Add fuel expenditure
#  # [DONE] Unit tests for ImperialDate
#  # [DONE] Add test suite
#  # [DONE] Unit tests for Credits
#  * [DONE] Add maintenance availability to StarSystem (A + B starports)
#  # [DONE] Unit tests for Cargo
#  * [DONE] Add annual maintenance
#  # [DONE] Unit tests for Ship
#  # [DONE] Unit tests for Calendar
#  * [DONE] BUG: price array isn't updated when we remove Cargo from the Depot
#  # [DONE] Unit tests for Financials
#  # [DONE] Unit tests for StarSystem
#  * [DONE] Longer intervals need to make sure repeating events execute multiple times
#  # [DONE] Unit tests for utilities
#  # [DONE] Unit tests for CargoDepot
#  * [DONE] Advance calendar for in-system activities
#  * [DONE] Review need for fractional credits ('cents') - not needed
#  * [DONE] First pass pylint cleanup
#  PHASE TWO =======================================================
#  * [DONE] Basic StarMap class with coordinate & distance functionality
#  * [DONE] Add select destination before jump (will tie in to subsector map,
#            world generation, possibly freight & passenger selection)
#  * [DONE] Flesh out jump action sequence
#  * [DONE] Fix handling of observers after jump
#  * [DONE] BUG: Command messages not displaying correct world post-jump
#  * [DONE] Thoroughly test jump scenarios, verify location is changed everywhere
#  * [DONE] BUG: StarMap.get_systems_within_range is returning only systems AT range
#  * [DONE] Set starting location to StarMap origin point
#  * [DONE] Move Command message into game methods
#  * [DONE] Examine observers post-jump (depot especially) to verify correctness
#  * [DONE] BUG: maintenance date discrepancy between Financials & Ship
#  * [DONE] BUG: possible to be at jump point with zero fuel, and travel inbound to -5 fuel
#  * [DONE] Color initial command message string to make it stand out
#  * [DONE] Validate coordinates in StarMap ctor before building dictionary
#           (is this YAGNI? think we will need if we have manual input of star map data)
#  * [DONE] BUG: inbound fuel check too strict, can't travel in post-jump
#           (fixed - but should we do the same for outbound? as long as there is
#            a gas giant it would be fine, but otherwise player can get stranded
#            potentially...)
#  * [DONE] Calculate three-axis coordinates surrounding an origin hex at given range
#  * [DONE] Implement JIT world generation to populate an 'infinite' map
#  * [DONE] World strings should include coordinates
#  * [DONE] Verify map persistence
#  * [DONE] Add command to list out the star_map
#  * [....] Create a proper UWP class and generator in the StarSystem ctor
#  * [    ] Write up a manual test script
#  PHASE THREE =====================================================
#  * [    ] Add freight shipping
#  * [    ] Add passengers
#  * [    ] Add unrefined fuel and its effects (and query of StarSystem)
#  * [    ] Add misjumps and other ship malfunctions (ties to unrefined fuel & maintenance)
#  * [    ] Add crew members with skills
#  * [    ] Add proper salary calculation per crew member
#  * [    ] Add survival odds for low berth passengers, and report results each trip
#  * [    ] Add low berth lottery
#  * [    ] Add shuttles to surface (esp. for unstreamlined ships)
#  PHASE FOUR ======================================================
#  * [    ] BUG: some payments don't check bank balance first - scrub & fix!
#  * [....] Make type dunder methods more robust with NotImplemented etc.
#  * [....] Extend payment flow model to reduce coupling between classes
#  * [    ] Review (and possibly deprecate) item_number return value from CargoDepot.get_cargo_lot()
#  * [    ] Assess need to unset berth recurrence/expiry on takeoff
#  * [    ] Review observer tests for boundary values and long intervals
#  * [    ] pylint/pydocstyle scrub
#  * [    ] DESIGN ISSUE: single-letter commands are becoming too restrictive    
#  * [    ] DESIGN ISSUE: player can cancel and retry sale to get a better price
#  * [    ] Refactoring suggestion: have Ship own Financials (or other way around?)
#  * [    ] Refactoring suggestion: inbound/outbound methods in Game are almost
#           identical, and should be merged (consider fuel cost warning & stranding)
#           (Add another warning if fuel at 'stranding level' and no gas giant?)
#  * [    ] Should we have a 'stranded' condition? Pay for a tow truck?
#  * [    ] Need to be able to see maintenance date
#  * [    ] List star map to take a range parameter?
#  * [    ] Can we colorize current location in star map listing?
#  * [    ] Consider generating new star systems when jumping in, rather than
#           when jumping out as in current implementation
#  * [    ] Should we extract all the three-axis coordinate math to its own class?
#  * [    ] Lift all print statements out of model classes
#           (this might resolve the skipped tests - if not, that's a separate TO_DO)
#  * [    ] Learn how to use mock.patch to deal w/ side effect testing (stackoverflow 21046717)
#  * [    ] Review applicability of dataclasses/namedtuples (stackoverflow 47955263)
#  # [    ] Break up Game class (MVC?)
#  * [    ] Review flow, confirmations, notifications - streamline where annoying,
#           slow down where mistakes happen
#  * [    ] Assess whether rounding in Credits ctor can cause errors
#  * [    ] Replace dummy/test data with 'real' values
#  * [    ] Consider moving tests to separate modules
#  * [    ] Shotgun surgery between starting commands and star system detail setting
#  * [    ] Move cargo data to separate data file
#  * [    ] Should we add type annotations?
#  * [    ] Add visualization of cargo purchase DMs (colorized trade codes?)
#           (should be able to view in hold and while trading,
#            possibly also while choosing a destination world)
#  * [    ] Add a 'shore leave' action?
#  * [    ] Ships with better than jump-1 should be able to choose short jumps too.
#  * [    ] Rather than having up-front tests, make some commands dynamically
#           available in command lists when conditions merit - e.g. only present
#           skimming as jump point command if the system has a gas giant
#  * [    ] Tie-in with game over and save/load game - add front end with
#  *         restart / new game options, including re-using same star map
#  * [    ] Add out-of-funds condition (game over?) (Block in Financials?
#           i.e. balance can't go negative?)
#  * [    ] Save game state
#  * [    ] Load game state
#  * [    ] Should/could we clear the screen?
#  * [    ] Adjust UI elements, play with more ANSI codes - also review color
#           coding for warnings, positive/negative messages, etc.
#  PHASE FIVE ======================================================
#  * [    ] Implement coordinate conversion to Traveller subsector row/column
#  * [    ] Add Navy/Scout bases to StarSystem? Only for color, yes?
#  * [    ] Maintenance assists, plotting routes to service centers
#  * [    ] Should we allow partial fuel fillup?
#  * [    ] Ocean refuelling option if hydrographics permit it (should we then
#            split out another surface location? Implication of current 'surface' location
#            is it as the starport, which this is not. Scope creep, maybe hold this one
#            until phase five...
#  * [    ] Add extended StarSystem details
#  * [    ] Add different ship types and ship design
#  * [    ] Add a transaction ledger to Financial class
#  * [    ] Review need for negative or zero credits (balances and debts?)
#            Defer - currently all uses are positive, even debts, but haven't
#            implemented a ledger or more accounting features yet
#  * [    ] Add loan history and statement (amortization schedule too?)
#  * [    ] Distinguish between highport and downport
#  * [    ] RPG lite elements: named crew, brokers, color events & encounters, etc.
#  * [    ] Color: jump dimming
#  * [    ] If we want to expand beyond just the trade model, add 
#            ship encounters (Book 2 p. 36), hijacking, piracy, etc.
#  BEYOND ==========================================================
#  * [    ] Alternate shells: GUI, 'Oregon Trail style', etc. Would be amusing to
#            do ASCII graphics...
#  * [    ] Non-canon variations and features - draw from other RPGs, board games,
#           videogames, and brainstorming
#
