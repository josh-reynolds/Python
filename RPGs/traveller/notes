# Trading procedure (Traveller 77 Book 2 pp. 42-4)
#
# Once per week, throw d66 to determine best cargo
#   DMs per world population
# Determine quantity
# Purchase if desired, up to limits of quantity
#   and available cargo space
# Partial purchases incur 1% fee
# Determine price of goods by 2d6 roll on table
#   DMs per skills, brokers, world characteristics
#
# Can sell cargo on a (different?) world
# Sale price by 2d6 roll on table
#   DMs per skills, brokers, world characteristics

# So overall sequence would be:
# Enter trade depot and see available goods
# Choice: wait a week, purchase some or all, jump to new system
# (And at any point can sell cargo in the hold)

# Other elements we will need:
#   time/calendar (so we will want to display current time...)
#   world characteristics
#   cargo tables
#   bank account (also need to display/query this...)
#   brokers for hire
#   character skills
#
# Not covered in this section, but eventually will want
# starship economics (Book 2 pp. 5-8)
# Operating expenses:
#   fuel
#   life support
#   routine maintenance
#   crew salaries
#   berthing costs
#   bank payment
#
# The starship economics section also covers freight
# shipping (flat rate - above is speculation) - add
# this option eventually. Also passengers.

# Ship design and customization is another potential
# area to explore. We'll assume a simple standard design
# (like the Free Trader) to start with.

# The star map will be a whole 'nother thing. A couple
# potential approaches:
#   Traveller subsector maps, whether generated or
#     loaded from a file
#   On-demand world generation - of course will need
#     to persist these systems as they are created

# UI thoughts:
#  as long as we're text-based, might want to play with
#  more ANSI code formatting to distinguish various things
#
#  also think about persistent display sections, rather than
#  always having to query data points
#
#  will need to make all the input much more robust - it needs
#  to handle bogus input appropriately

# -------------------------------------------------------------
# Comments about individual cargo unit_size assessment, prune
# through this and retain if any is useful...
# ---------------------------------------------------
# This data might belong in the cargo tables rather than here
# also, the RAW is very handwavy about tonnage for individual items,
# basically says "figure it out" - only some of these items
# are in the equipment list, so I'll fill in something plausible
# as best I can
# 
# Equipment list comparisons drawn from Book 3 (pp.16-7)
#
# Also need to consider that tonnage should be _displacement tons_
# not mass, so fiddle with the numbers supplied as necessary
# and there's packing material to consider too, as they call out in
# the example on Book 2 p. 43
#
# Per Traders & Gunboats p. 5, a 1.5m deck plan square, floor to
# ceiling, is half a displacement ton - so a 100-ton ship has
# 200 grid squares in theory. Yes, cargo hold ceilings might be
# higher than 3m, but this is a good enough basis for converting
# length/width into displacement numbers.
#
# Of course if we're dipping into sources later than the original
# three LBB, then we should be able to look all this up directly.
#
# Another observation - Traveller 77 trading setup does not consider
# Tech Level at all. Some of the items below might not be 
# producible on a given (low-tech) world. Can hand-wave by 
# assuming they are off-world products being warehoused here...
# 
# We'll assume the aircraft are less dense than the ground vehicles
# and fiddle with mass to volume ratios accordingly
#
# assume TL5 Fixed Wing Aircraft based on price
# weight 5 tons, cargo 5 tons, length 15m, wingspan 15m

# assume TL8 Air/Raft based on price
# weight 4 tons, cargo 4 tons
# the Scout/Courier deck plans in Traderes & Gunboats
# allocates 12 grid squares to its Air/Raft, so 6 d-tons

# not listed - base this on ship's computers
# closest fit is the Model/2bis, which costs a bit more
# (12MCr vs 10), and displaces 2 tons

# assume TL6 All Terrain Vehicle based on price
# weight 10 tons

# assume TL6 Armored Fighting Vehicle based on price
# weight 10 tons

# not listed, will need to guesstimate
# let's just assign it the same stats as ATV/AFV
# -------------------------------------------------------------

# -------------------------------------------------------------
# I'd like to ease the remaining coupling, don't like passing objects
# in to all the ctors, everything has access to everything. It's better
# than the previous global resource abuse, but could be better.
#
# The model I arrived at in Ship.refuel() may provide the way. It 
# handles its own data, then passes back the cost to the caller, which
# then passes it along to Financials. If we allow multi-dimensional
# costs (money, time, fuel, space), then the component classes could
# be properly ignorant of one another. Only the master Game class
# (which holds references to everything already) would know. This is
# something like a service bus - a blob of data flowing down a pipe,
# with individual components choosing whether to take action or not.
#
# Calendar (ImperialDate)
# ImperialDate
# Cargo (Credits)
# CargoDepot (Cargo, ImperialDate, Credits, Financials, Ship, StarSystem)
# Financials (Credits, ImperialDate, Ship, StarSystem)
# Credits
# Ship (Credits)
# StarSystem (Ship, Financials, CargoDepot)
#
# Should distinguish importing a class vs. calling methods or
# accessing fields on an existing object. The former is OK, the
# latter is coupling.
#
# The data classes (ImperialDate, Credits, Cargo) are fine, and
# right now Ship and StarSystem (with a minor exception) are in
# the same category. StarSystem owns CargoDepot - otherwise it
# is not coupled at all, so moving the latter up seems like a 
# good move.
#
# Almost all the logic outside of the master Game class is in
# CargoDepot, Financials, and Calendar. Those are the focus.
#
# So, after some initial shuffling, we now have:
#
# [OK] ImperialDate
# [OK] Calendar (ImperialDate)
# [OK] Cargo
# [  ] CargoDepot (Cargo, ImperialDate, Credits, Financials, Ship, StarSystem)
# [OK] Credits
# [  ] Financials (Credits, ImperialDate, Ship, StarSystem)
# [OK] Ship (Credits)
# [OK] StarSystem
#
# So, the model I think we're striving for is all actions involve
# invoking a series of sub-actions which return multi-dimensional
# costs, then passing the costs to the payees. Tempting to create
# a little class to represent costs, but that's overengineered at
# this point. Keep it to a simple tuple until we need more.
#
# Current actions:
#   quit
#   list commands
#   cargo hold contents
#   view world characteristics
#   wait a week
#   lift off to orbit
#   trade
#   refuel
#   go to jump point
#   land on surface
#   jump to new system
#   inbound to orbit
#   leave trade
#   show goods for sale
#   buy cargo
#   sell cargo
#
# There will of course be others, like skimming fuel, but these
# give a good sampling of what to expect. A few types:
#
# State transitions (quit, lift off, go to jump, land, jump, inbound, trade, leave)
#     Change state on object, may have a time cost
# Informational (list commands, hold contents, world chars., show goods)
#     Pull information from object
# Actions (wait, refuel, buy, sell)
#     Interact with objects, may have multiple costs
#
# These distinctions are pretty arbitrary, at least between the first
# and third. And in some ways even the second if you allow zero-cost as
# a thing. Anyway.
#
# So next step might be to make all actions (Command objects) correspond
# to a method on Game, and not allow them direct access to the child
# objects. Most pressing for buy/sell, but even the simple informationals
# should comply.
#
# Separating the child classes from interface actions (like print
# in the current UI paradigm) is also probably a good thing. They don't 
# need to know whether their output goes to the console or a
# GUI window. Be cautious of YAGNI of course. But still, if this is
# something like MVC, then the child objects are MODEL and shouldn't
# display anything at all.
#
# There are separate issues for the two classes still needing decoupling.
# CargoDepot is coupled in buy/sell cargo, which are both very long methods.
# Financials is coupled in notify and the tasks it calls.
#
# For the former, should break up the methods into small pieces (that
# still live in CargoDepot), then move the orchestration logic up to
# Game.
#
# For the latter, lift the observer up to Game - just add this logic in
# wait_week. At that point we only have one observer so the entire thing
# may not justify its existence, even though it isn't causing any problems
# in CargoDepot.
#
# OK. CargoDepot buy & sell have been broken up, and lifted into
# Game. This opens the door to removing references to Ship &
# Financials and fully decoupling the class. Methods of course will
# continue to slide around to appropriate homes as we go, but for now
# this is pretty clean. (I _do_ envision some sort of split of Game
# itself, possibly along MVC lines. We may end up pulling too many
# things up and that class will become bloated. One step at a time.)
# -------------------------------------------------------------

# -------------------------------------------------------------
# Another question is how to handle per-trip fuel costs.
# One model is to assess a cost for travel out to the
# jump point, and again for inbound. That does leave open
# the possibility of the ship being stranded.
# Alternative would be to assess the full trip cost on 
# landing.
# In both cases, there's the question of the player gaming
# the system and either evading costs or getting stuck.
#
# Could add a check before outbound to jump point that the ship
# has at least 2x cost (for there and back).
# -------------------------------------------------------------

# -------------------------------------------------------------
# We'll use the standard Imperial calendar, though that didn't
# yet exist in Traveller '77
# year is 365 consecutively numbered days
# date displayed as DDD-YYYY
# seven day weeks and four week months are used to refer to
# lengths of time, but rarely to establish dates
# (of course fun math, 7 * 4 * 12 = 336, so we are missing
# 29 days - but since week/month are really just durations
# it shouldn't matter)

# right now we only have refreshing the cargo depot weekly as an
# event, but there will be more:
#    * monthly loan payment
#    * annual maintenance
#    * monthly crew salaries
#    * daily berthing fees for extended stays
# other operational costs might better be handled as resource modeling:
#    * fuel
#    * life support

# also need to advance the calendar while in-system
# RAW says that ships typically take two trips per month:
# each jump is one week, and they spend a week buying & selling
# cargo, finding passengers, and on shore leave

# two approaches:
#    * give each action a cost in days
#    * advance the calendar only on jump and liftoff (the latter
#        perhaps with a message like 'you spent a week on Yorbund')

# for the former, does it add up to about a week? and do we want the
# player to be fiddling with time as well as money and space?
#    * to/from jump point - 1 day each
#    * to/from orbit - no time, don't want to privilege highport
#    * buy cargo (and load into ship) - 1 day
#    * sell cargo (and load into ship) - 1 day
#    * find passengers (and embark) - 1 day
#    * find freight (and load into ship) - 1 day
#    * listing hold/depot contents - no time
#    * refuelling - no time at port, 1 day to skim 
#    * recharging life support?
#    * financial transactions - no time
#
# easily 6-7 days if the player does all activities
# but if they want to go fast, jump in, skim fuel, jump out - just
# one day? or even no delay if they have reserve fuel.
#
# Alright. I think I'll add time costs per the schedule above, and
# see how it plays. We're applying costs in the action methods in
# Game, so this should go there as well.
# -------------------------------------------------------------

# -------------------------------------------------------------
# Will want to consider what aspects of the starport to bring into
# play. Fuel availability for sure, as well as maintenance
# availability. Need to mull over minor damage and whether other
# repair facilities should be accounted for. Bases? Probably easy
# to add, have no real play effect, just color (could influence
# ship encounters, but even those are mostly color at least in the
# initial version). Ship construction is also for some future 
# version, if ever.
#
# Interesting that starport has no impact on trade. You'd think
# that an E or X class at least has minimal to no cargo available.
# But let's not critique the system just yet. I'll fill in ambiguous
# areas as needed, but otherwise keep to RAW. Later maybe we'll
# explore other editions and/or homebrew our own trading rules.
# -------------------------------------------------------------

# -------------------------------------------------------------
# Sketching out annual maintenance procedure.
# Book 2 p. 6
#   Annually, a starship should be given a complete overhaul...
#   Such maintenance costs 0.1% (1/1000th) of the cash price of the 
#   ship, and requires two weeks at a class A or B starport...
#   Crew members generally take their vacation at this time, but 
#   must still be paid. Provision should also be made for the 
#   expected loss of revenue while the ship is out of service.
#
# So, I think to start with, we flag the ship with a 'last 
# maintenance date' - use the start point of that two week
# period.
#
# Then we should be able to calculate 'days since last 
# maintenance.' This function will need to know ship maintenance
# date as well as current date. Model we use in Financials
# for other expenses (invoked from Game) ought to work.
# 
# May want to report on maintenance age, at least when it starts
# approaching a year. (Exact date ought to be visible all the 
# time from ship details.) Something like:
#  GREEN - maintenance less than 10 months ago - don't report
#  YELLOW - maintenance 10-12 months ago
#  RED - maintenance more than 12 months ago
#
# Financials already has a reference to ship that I have not
# refactored away. Intended to do that, so adding the method
# there is a bit backward, but whatever model we decide to 
# decouple will apply here too, so no real harm. (There is some
# logic to tightly binding Financials and Ship as well, so
# perhaps one should own the other. Later refactorings will help
# suss this out.)
#
# At least two mechanisms from there:
#  * if maintenance status is RED, there is a chance of drive
#    failures and/or misjumps (Book 2 p. 4)
#  * we'll need a 'perform maintenance' action at starports, which
#    advances the calendar two weeks, charges the appropriate cost,
#    and resets the maintenance date on the ship. Since it can
#    only be performed at class A/B starports, would be nice to
#    have this command dynamically available, but if not, it should
#    block at inferior sites.
#
# Beyond that, if we want to get fancy, would be nice to provide
# some assists to the player. They will want to know how far the
# closest A/B starports are, and gauge travel times.
# -------------------------------------------------------------

# -------------------------------------------------------------
# Reviewing the calendar observers. There are a couple goals:
# * Financials is coupled to Ship and StarSystem in notify. If
#   we remove or lift that, we'll only have one observer, so
#   the entire pattern is in question here. It may be 
#   over-engineered for the actual use case.
# * Feature-wise, we need to make sure that repeating events
#   (which is pretty much all we have) execute multiple times
#   if the duration is long enough. That doesn't seem to be
#   the case with the current implementation, though it's 
#   tricky to tease out. Maybe a mock observer and test case
#   to help peel it apart? But the solution may need to be
#   in the observer with current, because they know their
#   date and frequency.
#
# Observer test scaffolding is in place, so we can play around
# with this. But also, on reviewing, Calendar doesn't have a
# very clear reason for existing. It holds an ImperialDate, and
# a list of observers that it notifies upon change. Some of its
# logic duplicates functionality already in ImperialDate. And if
# we lift up the observer stuff to Game, there's not much here.
#
# Conceptually, a Calendar ought to hold _multiple_ dates, right?
# That's what makes it different from just a date. I think I was
# initially heading in that direction. So, whatever blob of code
# holds the observers should probably also hold their dates. Or
# to put another way, when an observer registers, it ought to 
# register the date that it cares about (or schedule? or 
# frequency?). That would bring the logic that decides how to
# fire actions in scope here, and not scattered across all the
# observer classes (we only have two right now, but anyway).
#
# Components of a schedule:
# * notification date
# * due date
# * recurrence
#
# Current (bugged) logic:
# 1) if notification date is later than due date, execute action
# 2) set next due date to last due date plus recurrence
#
# Should have a 'step 1.5' which is to calculate how many times
# to execute the action, based on the duration between notification
# and due dates. Financials.renew_berth() does that (though I'm not
# 100% sure it is fully correct; there's some odd 'renew for 6, renew
# for 1' behavior going on).
#
# Ah! Think I just spotted the bug in Financials...
# 
# OK. Fixed. But also, I now think 'due date' is mistaken. We should
# have 'paid up date' (whatever concise name should go here...). And
# due date is actually every _recurrence_ thereafter. These types of
# events, we're not providing an option to pay early, so they will
# always be on predictible days in the future. So calculate an integer
# division (_not_ modulus) and set the paid date to the last such, 
# and move on.
#
# I was able to test drive this design, and it looks correct so 
# far. Only problem is that the interesting code lives in my mock
# observer, not in calendar. So to implement for real, I need to 
# apply this design to all of the existing observers. And though
# there's only two subscribed classes, in some ways each event is
# one. Potentially worth extracting into a class. We will see.
#
# Almost done with this work. Turns out there are slight variations
# in the model. Also Financials is riddled with side effects that
# I will need to address, so while the tests work and helped to drive
# the code to a better state, I will mark them skip for now.
#
# We have a total of five observer events to deal with:
#  1) CargoDepot.notify() - to refresh cargo selection weekly.
#      Refreshes cargo weekly, but doesn't need to execute
#      multiple times, just once if duration has passed.
#  2) Financials.berth_notification() 
#      Two phases: first part on landing, with six-day coverage.
#                  then a daily renewal after that.
#  3) Financials.salary_notification()
#      Standard observer model with a 28 day recurrence.
#  4) Financials.loan_notification()
#      Standard observer model with a 28 day recurrence.
#  5) Financials.maintenace_notification()
#      No recurrence. Just calculates a duration and reports
#      status. Resetting the state is via a separate mechanism.
#
# The 'standard observer model' is:
#  Observer:paid_date
#  Observer:recurrence
#  Observer:notify(date)
#      duration = (date - paid_date) // recurrence
#      for i in range(duration):
#          execute_action
#          paid_date += recurrence
#
# All done with the initial set of tests. Need to review to make
# sure the date ranges chosen make sense - though the tests are
# passing, I'm not 100% certain I chose good boundary values. Also,
# might not have emphasized the whole 'repeat on long ranges' thing.
# Still, scaffolding in place for improvements.
# -------------------------------------------------------------

# -------------------------------------------------------------
# Working through the design for multiple star systems. A few
# considerations:
#
# * Basics. Traveller maps the universe on a 2D hex grid. One
#   hex is one parsec, with each hex either being empty or 
#   occupied by a single star system. In Traveller '77 these
#   are very rudimentary, with no stellar characteristics and
#   only the 'mainworld' described at all. The standard map
#   is an 8 hex by 10 hex subsector (all that exists in '77) - 
#   later these were grouped into larger sectors (4x4 subsectors).
#
#   At least for the intial version(s), I will maintain the 2D 
#   hex grid standard.
#
# * Coordinate system. To distinguish different star systems, and
#   to calculate distances between them, we need some kind of 
#   coordinates. The standard Traveller subsector assigns each
#   hex a row/column coordinate - so they run from 0101 through 
#   0810. In the expanded sector arrangement, they run from 0101
#   through 3240.
#
#   But these coordinates can be a PITA to work with for anything
#   but simple layout. Calculating distances between two arbitrary
#   hexes is rough, and you need a second square (well, rectangular)
#   grid coordinate overlaying it to handle crossing subsector
#   boundaries.
#
#   In a previous project, I came up with a three-axis system that
#   works pretty well. Distances are trivial to calculate (the 
#   highest absolute value of any of the three coordinates). There's
#   also an interesting checksum built in - if the coordinate is
#   valid, its three values sum to zero.
#
#   Expanding on that, I had considered a 'circular grid.' Rather 
#   than arbitrary subsector boundaries overlain on the universe,
#   each world can effectively be the center of its own subsector.
#   Some products used to publish 'jump maps' that take this view,
#   like all hexes within 4 parsecs of some central world.
#
#   But again, the goal for this first version is compatiblity with
#   Traveller '77 RAW, so we should use the three-axis system
#   internally, with conversion to the standard row/column format for
#   display. My previous project already worked out the math, so we
#   can lift it.
#
# * Canon. Touched on above already. I don't mean canon in terms of 
#   setting. Traveller '77 doesn't have one, which is part of its
#   charm (though a bit is implied by things like Credits, naval 
#   bases, and so on, the Imperium is never mentioned).
#
#   I more mean 'rules canon.' As great as Traveller is, there's some
#   very clunky or outdated ideas in there too. And it is mighty 
#   tempting to 'fix' them.
#
#   For now, resist the tempation. I could see a future version
#   of this (or a spinoff) going in a different direction. The round
#   grid mentioned above is one idea (or a 3D grid). Lots of drift
#   to be found in later Traveller editions, especially in world
#   building and astrophysics. And I have some ideas about how 
#   interstellar cultures could work too. But all that is later.
#   Stick to RAW.
#
# * Dynamic generation. OK, this is finally getting into _how_
#   we're going to implement this feature. There are a couple 
#   basic approaches I can see:
#
#   * Dynamically generate star systems on the fly as we need 
#     them. Of course we also want persistence, so once 
#     generated we need to be able to get them back. And 
#     persistence across game sessions is a consideration
#     too - is the universe gone once you quit, or can you
#     resume play in it? I think eventually I'd want the latter,
#     though we could defer until later.
#
#   * Have a pregenerated map to work from. In practice, I would
#     probably generate the map rather than just enter in the data
#     from a published source. (Though the latter has some appeal
#     too - tooling around in the Spinward Marches would be fun.)
#
#   I think dynamic will be simpler to get working. Most of the 
#   pieces built there will also be useful for map generation.
#   And once we get persistent saved games, that will help us
#   figure out file formats and so on for the data entry
#   approach.
#
# * Coding strategy. All that said, still not sure exactly how
#   to tackle. Tempting to sketch out a bunch of classes and
#   so on. But probably better to work from in-game use cases.
#   That's been the approach so far, and it seems good. As with
#   test driven design, each next step is small and pretty 
#   obvious, even when you don't quite know where things will 
#   end up.
#
#   So let's start from the 'jump' action in Game. Figure out
#   what's needed there, and build out piece by piece.
#
#   * We need fuel & life support costs, jump range, and time.
#     All that is in place already.
#
#   * If the ship qualifies (enough fuel/support, and at the 
#     jump point), show all systems in range. At jump-1, that's
#     at most six.
#
#   * For the initial bring up, we can have a stub that just
#     returns a single system. And it should be able to swap
#     back and forth between that and our original world.
#
#   * The new star system can be mock data added by hand. 
#     Later we'll have some facility for generating a new
#     world, or looking it up on the internal map.
#
#   * Player selects destination, confirm and go!
# 
#   * Any global references that are tied to location
#     need to be fixed up. Already have some comments about
#     the observers and the command set in the traveller
#     module; wouldn't be surprised if there are others.
#
#   * Last, now that we finally have a reasonably comprehensive
#     set of unit tests and good-ish hygiene, the new classes
#     should be developed test first as much as possible, and
#     conform to pylint feedback too.
#
# * Beyond that initial feature, we'll definitely want:
#
#   * Ability to see the star map somehow. Might be interesting
#     in a text interface... Optionally being able to render
#     out as a bitmap might be cool. Also need associated 
#     UI actions.
#
#   * Hints for the player about things like nearest maintenance
#     depot, where frontier fuelling is available, etc.
#
#   * Of course save/load of star map data, as mentioned above.
#     (And UI actions...)
#
#   * Things like misjumps need to be considered. In some ways
#     very easy if we assume three-axis coordinates and dynamically
#     generated universe.
#
# OK, after all that, I almost immediately went off course. It's
# obvious we'll need some kind of map class to manage all the 
# systems. So I made a StarMap class. And from there, I started
# some simple tests to drive a basic interface. And that's 
# ballooning a bit. The strategy above assumed more of a mock
# StarMap that would only allow us to bounce between two
# hard-coded systems, but I'm building something more 
# full-featured (though still pretty simple).
#
# Questions we'll need to address (more of them):
#
# * Container for star systems. Very straightforward, and on
#   its own not enough to justify a class. I'll use a dictionary
#   with the key being a coordinate tuple. Tempting to make
#   another little class for coordinates, but premature I think.
#
# * Coordinate system and 'space.' We need to be able to distinguish
#   separate star systems, to calculate distance between them, and
#   so on. Per the above, coordinate system will be three-axis. My
#   test driving right now is building up that functionality.
#
# * Travel basics. This is the section above. We can hard-code
#   a map of just two systems and then build up travel mechanics
#   until they're set.
#
# * Populating the map. Once that is all working satisfactorily,
#   we'll need to decide how to fill in the map. Since we want
#   dynamic, this will be a JIT system. Request a system by 
#   coordinate. If it's in the container, return it. If not,
#   generate it.
#
# * Generation of star systems. Finally, we'll need to be able
#   to create new systems on the fly. Initially we'll just have
#   hard-coded values, but will need to create for real 
#   eventually. Traveller world generation procedures are 
#   easy to implement, so not a big deal. World name generation
#   may be the most interesting part.
#   
# First two above are basically done. May be tweaks later, of
# course. Time to work on travel mechanics.
#
# Travel is working! We can finally move between systems and
# trade goods. The basic game flow is working. Lots of polish
# and little features to add from here, of course. I want to do
# a little more testing and handle some rough edges spotted
# during playtest, then we'll get the JIT generation up and running.
#
# For JIT, we need a few things:
#
# * First, the methods in StarMap need to accommodate a 'None'
#   entry in the system dictionary.
#
# * Second, we need to be able to calculate coordinates relative
#   to an origin. We can handle distances, but generating new
#   coordinates, not quite yet. One approach is to handle
#   as a set of translates - for example, extending the axial
#   rows is as simple as repeatedly adding the appropriate
#   edge hex from the first ring. And the hexes in-between are
#   a combination of translates along two axes.
#
#   Another observation is there are axis rows, and six 'pie
#   slices'. At a given range, there are exactly six axis hexes,
#   and (range-1)*6 edge hexes.
#
#   And another - if you look at a diagram and figure out a 
#   given edge hex's coordinate (axis hexes are trivial), stepping 
#   along the two axis rows that bound its slice and adding those
#   two axis hexes together gives the result, just like with
#   Cartesian coordinates. So you just need to keep track of
#   which two axes govern that slice. (And of course adding
#   two coordinates together is basic vector translation...)
#
#   I have this working for everything except the edge hexes. Need
#   to work out the formula. But another idea occurred to me. What
#   if we just create the full set of potential hexes based on range,
#   then eliminate the invalid ones? Tempted to do this and see
#   which is more performant. I think this new idea would be less
#   code at a minimum, and probably easier to comprehend, than 
#   some geometry-based logic.
#
#   As it turns out, the list comprehension approach was very
#   easy to build and verify. And certainly less code overall.
#   Probably more readable to as long as you're comfortable with
#   the syntax. I stripped out all the geometry-calculating
#   methods. Maybe sometime it would be interesting to figure
#   out, and I suppose there's a theoretical performance
#   question to understand, but at the scale this program is
#   working, I don't think it's meaningful. I hope. Stress test 
#   with a _really_ big map? What's the big-O for my algorithm?
#   There is a cube of range involved in get_all_coords(),
#   which makes me a bit leery. We probably only ever run
#   it with small numbers. Jump-6 is the maximum in Traveller,
#   and a reasonable maximum for grabbing a bunch of coordinates
#   all at once. We'll keep an eye on performance and see.
#
#   OK. Tried out a jump-6 ship, and the current implementation
#   generated 60+ worlds in an eyeblink. No observable
#   perf issue at this scale (and per Traveller canon, jump-6
#   is the largest possible. Mijumps don't count for this
#   purpose.) So practically speaking, we're good.
#
# * That done, the last bit is easy: get_systems_within_range()
#   should look at all hexes by coordinate, not by what is present
#   in the dictionary. An if a given coordinate is not in the 
#   dictionary yet, generate it. The result will be either
#   None or a StarSystem.
#
# All this is working. The map is effectively infinite, with 
# new systems being added around the edges as needed. Right 
# now they're all hard-coded to a test value. Need to create
# some kind of factory to build them. But it works!
#
# I did a bit more validation, and some manual testing flying
# around this little galaxy. It pushed me to implement some
# better visibility into the map, so coordinates are now shown
# when printing StarSystems, and we have a command to dump out
# the entire map at will. It is persistent within a session - 
# I can travel across the map and back, and still see the same
# (generated) systems in the same places. On to world factory.
#
# And we're done. Infinite map with real Traveller worlds. I
# still don't have a naming system in place, but the data looks
# good and everything appears to be working correctly. This is
# MVP. I want to capture a manual test script before moving on,
# and take closer look at a few things, like dates and map
# structure. Then we can add minor features, color, and polish.
#
# Test plan is complete, and after playing around a bit, 
# things look correct. Only issues I've spotted so far are
# expected design issues I haven't gotten to yet. I also 
# scribbled on a map, and the generated 'galaxy' hangs 
# together properly, with persistence and adjacency as
# expected.
#
# One tweak I want to make next: it makes sense to generate
# worlds when jumping _in_ to the system. It's like being
# able to see immediate neighbors, and will be necessary when
# generating freight/passengers anyway. Current implementation
# only does this when we attempt to jump _out_.
#
# Problem is that calling get_systems_within_range() is the way
# to do this, and is proper whether or not neighboring systems
# have already been generated. But regardless of which, it will
# always call the potentially-expensive get_coordinates_within_range().
# At the jump-1 scale I'm currently testing this is not an 
# issue, but per the perf discussion above, maybe it will be?
# Need to profile and test of course. And if it _is_ an issue,
# we could always set a 'visited' flag on the system so we 
# don't run it again. 
#
# Ah, with a bit more thought... the second call to the method
# is really for its side effect, and the first call hopes
# it has already been called. So maybe this should be split up?
#
# And yet another thought. If we split it up, the pre-jump
# version would just dump out the contents of StarMap.systems,
# filtered by range from origin. Danger there is if current
# world is somehow not 'visited' this list would be incomplete
# and could change later. (Not sure how we'd get into this state,
# just spitballing.) To protect, I suppose we could return
# all systems, including None, and validate return list length
# by an easily calculable 'hexes within radius' formula. Then
# filter out None before displaying. Meh, probably too much
# fiddling.
# -------------------------------------------------------------

# -------------------------------------------------------------
# OK, next up is freight and passengers. Let's tackle freight
# first. It piggybacks on cargo somewhat, and the rules state
# passengers present themselves _after_ a freight destination
# has been chosen.
#
# First, the basic procedure per the rules (Book 2 p. 7):
#
#   The referee should determine all worlds accessible to the 
#   starship (depending on jump number), and roll (for each such
#   world) a number of dice equal to the population number of the
#   destination. Each die represents one shipment, expressed in
#   multiples of 5 tons... A starship can carry as many shipments
#   as will fit in the hold, but may not break down the size of 
#   any specific shipment... Cargo is normally shipped at a rate
#   of CR 1000 per ton.
#
# So, some observations:
#
# * It's implied that these destinations are all one jump away,
#   so hopping across several connections is not OK. The shipper
#   would just select a higher-jump transport.
#
# * Continuing from that point, there's a time limit, meaning
#   the player cannot select cargoes from more than one world.
#   They never state this explicitly, but it reads that way to
#   me. The text of the passengers section reads similarly.
#
# * I've already established that cargo loading takes one day;
#   the same should apply here. But! This should not be per
#   shipment. The player should be able to select several
#   shipments, then one day passes for them all to be loaded.
#
# So, roughing out the steps and pieces we'll need:
#
# * Obviously a 'load freight' command from the trade depot.
#
# * And by implication, an 'unload freight' on arrival. This
#   one will be comparatively simple. Just time and payment,
#   and removing from the hold.
#
# * After executing the command, show a compound list:
#
#   * Headings are worlds within range
#   * Entries within each heading are shipments, just tonnage
#
# * Not sure yet how the interface should work. Select a world
#   first, then prompted to pick shipments (displaying total
#   size and remaining space each time), followed by a 'load'
#   to wrap up?
#
# * Of couse the player should be able to cancel out at any
#   point with no penalty. They have to be able to browse.
#
# * Loaded freight will appear in the cargo hold. Not sure if
#   we can overload the Cargo class to handle, or will need
#   something else. Freight only has three data points: source,
#   destination, tonnage. (Date and expiry? Check later rules
#   for embellishments, down the road.)
#
# * Another blind spot in the rules: how often is the freight
#   list refreshed? Seems simplest to align with cargo. Every
#   week there's a new bunch of freight. And of course we need
#   to maintain the list between refreshes.
#
# * Freight should be blocked (or better yet hidden) from the
#   'sell cargo' procedure.
#
# * Interplay with passengers is interesting. That procedure
#   (we'll get to in a bit) states to generate passegers for
#   the selected freight destination. But what if there isn't
#   one? Player either doesn't want freight, or does passengers
#   first? In this (freight) procedure, we only need to worry 
#   about the second option. Should we restrict the freight 
#   list if passengers have bought tickets for a destination?
#
# Basics are working here. The load_freight() method is a bit
# hairy, so will need cleanup. And I'm discovering lots of
# corner cases, playing a bit of whack-a-mole.
#
# -------------------------------------------------------------
# destination           hold
# -------------------------------------------------------------
# None                  No freight            OK
#                       Freight - local       BUG
#                       Freight - other       BUG
# Contract = local      No freight            OK if passengers
#                       Freight - local       OK
#                       Freight - other       BUG
# Contract = other      No freight            OK if passengers
#                       Freight - local       BUG
#                       Freight - other       OK
#
# Constraints on freight (and by extension passengers):
#   * Destination flag must be set if there is freight and/or
#     passengers on board
#   * All freight (and passengers) are for the same destination
#   * Destination flag must match freight/passenger destination
#
# Could/should the flag be dynamic, set via query property? Yep.
# Seems to be an improvement.
#
# Almost done with freight. The last significant piece is making
# the freight list persistent. Currently it's refreshed every
# time the player invokes the command. They could game the system
# by repeatedly spamming and exiting to get exactly the freight
# they want. Not a game-breaker I suppose, but it's also
# 'unrealistic.' Freight, just like cargo, should show up
# more slowly.
#
# Another benefit is this is pushing me to refactor the ugly
# load_freight() method. I conciously put that together all
# in Game, knowing it would need cleanup once I understood
# the flow.
#
# That's progressing but I'm on the threshold of a slightly 
# larger change. Freight needs to know about destinations.
# Currently I am only generating destinations in three
# places - twice in jump() and once in load_cargo(). And 
# the only place the information is persisted is the 
# StarMap dictionary. I think it would be helpful if
# StarSystems knew their 'neighbors.' Yes, this is specific
# to the ship in question, not the StarSystem proper, but
# I don't envision any way for the player to change their
# jump capability for a long time, if ever.
#
# So, seems like rather than in jump, we should generate
# when we create the System. If we do it in the ctor, we'll
# need to couple too many things IMO. But how about in
# StarSystemFactory? For that to work, we'll first need
# to get rid of any 'bare' invocations of the StarSystem
# ctor. Another method that allows us to specify the 
# attributes, rather than rolling randomly, should do the
# trick. Let's go.
#
# There _is_ a bit of chicken and egg going on with destinations,
# at least for the first few worlds. If we add them in a batch
# (as we're currently doing for our test galaxy), then we can't
# generate destinations world-by-world, or we'll get discrepancies.
#
# We may need two different approaches:
#
# * When batch creating worlds, iterate through and generate _after_
#   the batch is created. (Is the thumbprint here the StarMap ctor
#   and/or StarSystemFactory.create())
#
# * When creating worlds individually, you can create at the same
#   time, as we're adding just the one to the map. But! There's an
#   infinite recursion lurking here. If we naively keep going back
#   to StarSystemFactory.generate(), and it keeps calling itself,
#   this will blow up. We need a base case. That may be based on
#   'visited' (new flag, just spitballing). We only generate
#   destinations for visited worlds. But doesn't that put us back
#   to the current implementation? Generate when we jump in?
#
# OK. So the StarSystemFactory changes we just made are fine. Don't
# think we need to revert. But that's _not_ the place to generate
# destinations. It's when we jump in. (This also circumvents the
# whole 'if the ship changes' theoretical problem, as it is
# directly tied to a Ship instance making a jump.)
#
# In that case, we're almost there. Jump is already calling this,
# and by definition we need to have jumped to a world before
# entering the trade depot. So we're covered (for everything but
# the starting world...). Just need to have the work done in
# Game.jump() preserve its data in the StarSystem class.
#
# -------------------------------------------------------------

# -------------------------------------------------------------
# OK. Freight is done. Still needs more refactoring and some
# careful testing, but unit tests and manual test runs look good
# so far. Time to sketch out Passengers.
#
# Rules procedure (Book 2 pp. 7-8):
#   After a starship has accepted cargo for a specific destination,
#   passengers will present themselves... Consult the passenger
#   table: roll the number of dice specified in the originating
#   world column. From the result, add or subtract the stated 
#   number in the destination column. Roll separately for high,
#   middle and low passage. Treat worlds of population level
#   greater than 12 as level 12. (NOTE: this ruleset cannot 
#   produce worlds with population > 10)
#
#   Passengers will pay the standard fare for the class of
#   tranportation they choose (CR 10,000 for high passage,
#   CR 8,000 for middle passage, CR 1,000 for low passage).
#   Passage is always sold on the basis of trasport to the 
#   announced destination, rather than on the basis of jump
#   distance.
#
# First, thematically I think passengers should not come from
# a CargoDepot. Functionally they may be the same thing, but 
# there ought to be a Passenger Terminal. Both a class (analogous
# to CargoDepot, and possibly functionally identical), and a
# location just like 'trade depot.' So step one is to 
# stub out the state transitions and class.
#
# Second is timing. Seems like the player could sign up 
# passengers at any time. From the POV of the passengers,
# they want to know a departure date, and won't board
# until then. Low-berth passengers could take some time to
# load, but the others ought to be a fairly short affair, so
# not sure we should assess a time penalty here. The player
# chooses passengers for a destination (which may be restricted
# if they are already under contract for freight), and they 
# are considered 'loaded' immediately (not sure it's worth 
# the hassle of signing them up, then only changing the manifest
# just before launch... would mean too many fiddly steps for the
# player to deal with).
#
# Similarly, the passengers will want to disembark immediately
# upon arrival at their destination. For color, in the offload
# message we can have something about going to the passenger
# terminal, but I don't think the player should have to 
# invoke this. It should be automatic on landing (or docking
# with high-port, once we have that) much like assessing
# berthing fees.
#
# But what about low berths, and the low lottery? Hrm. Should
# we separate walk-on passengers procedure-wise?
#
# OK, so assume all that is sorted. We can load and unload 
# passengers, and presumably get paid at the destination.
#
# We'll need some sort of structure to store the passengers,
# and distinguish between the categories. A very simple scheme
# would be a flat list with entries of H/M/L. We'd need integrity
# checks to make sure these don't overflow the available space.
# And we want to be able to report on occupied berths. (Long
# term color, having named passengers would be nice. And there's
# the question of potential hijackers too...)
#
# I've settled on a tuple for passenger counts, and an enum
# to index into it. Seems simple enough. We may need to expand
# to a full class later if we add names and so on, but right
# now a passenger is a very simple entity, much like freight.
# (Though come to think of it, just like freight they also may
# need to track destination, or we need to account for it somehow
# for the destination property to work. Currently I just track
# counts by passage type. This will evolve.)
#
# OK, yeah, destination is a stick in the spokes. Plus the
# enum syntax isn't as smooth as I'd hoped. To use as an
# index into the tuple you need to access the value field.
# It's very verbose and feels like I'd be better served with
# a few constants. But also, where to stash the destination?
# I toyed with a fourth field in the tuple, but that causes
# issues when we zip them up for tuple element addition. I
# think we should have a Passenger class similar to Freight.
# Figuring that out now.
#
# We'll also need a selection loop at the terminal similar to
# how freight works. Keep picking passengers until satisfied.
#
# Passengers might be more dynamic than freight. Not sure yet
# about how/when to refresh or persist the list. Though you 
# could imagine at a low-traffic world, the list is pretty static
# and the passengers may be forced to wait until transport
# comes through.
#
# So our flow is:
# * From the Starport, go to the Passenger Terminal.
# * If a destination has been contracted, use that, otherwise
#   allow choice just like with Freight.
# * Player is presented with a simple list of passenger
#   counts, by High/Mid/Low. And should also be able to 
#   see their available/occupied berths.
# * Player prompted to choose passengers. Not sure yet how,
#   seems awkward to ask 'how many High?', 'how many Mid?' etc.
#   But don't yet see a slicker way to get the input (at least
#   in a text-based UI).
# * As with Freight/Cargo, will need to reject selection
#   if there isn't enough space left.
# * Once passengers are committed, the passenger manifest is
#   updated and the destination is set if not already. Same 
#   integrity constraints here as Freight. Manifest needs
#   to show destination.
# * All this takes no time. Assumed that passengers are loaded
#   before launch. In fact we probably should add a message
#   to the launch command if any passengers have booked.
# * Then the ship proceeds to jump and heads to destination.
# * Same considerations as Freight. But even more so - Passengers
#   will not be happy if the ship doesn't go directly to the
#   destination. Think about the penalty suggestion here.
# * On arrival and landing at the destination, passengers
#   automatically disembark, and the player is paid. Message here
#   too to that effect.
#
# Actually seems pretty simple, since we've worked a lot of
# this out in Freight already. We'll see as we dig in.
#
# Lots of room for color with Passengers, of course, as 
# mentioned already. Names, personalities, events, RPG stuff.
# Could have random chance of long-haul passengers (which would
# change the algorithm a bunch, since we're constraining both
# Freight and Passengers to a single one-jump destination at
# present). Hijackers too (which has a small system in RAW
# to piggy-back off of).
#
# -------------------------------------------------------------

# -------------------------------------------------------------
# ROADMAP
# Mulling over how to tackle ever-increasing TO_DO list.
# I think we can chunk the work into a few phases:
#  PHASE ONE
#  * Full feature set for in-system speculative trading. Just a few
#    maintenance costs left to go.
#  * Basic travel & resources features.
#  * Refactoring. In the midst of a big push right now.
#  * (Should really take my medicine and get tests/pylint/etc. done)
#  PHASE TWO
#  * Jumping to a new system and all it implies:
#    * Multiple systems
#    * Star map
#    * Coordinate system
#  PHASE THREE <== we are here
#  * Adding freight & passengers
#  * Any other remaining RAW procedures:
#    * crew, misjumps, etc.
#  PHASE FOUR
#  * Polishing game mechanisms:
#    * UI work
#    * Front end and menu
#    * Save/load if not done earlier
#    * Player customization: ship name, captain, etc.
#    * Save/load
#  PHASE FIVE
#    * Expand scope with RPG-lite elements and events
#    * Lift into graphics system? (This could really snowball, be cautious)
#    * Explore later Traveller versions for ideas (or to support as options)
# -------------------------------------------------------------

# --------------------------------------------------------------
# Consolidating TO_DO list:

#  PHASE ONE =======================================================
#  * [DONE] Create a currency class to keep value vs. display straight
#  * [DONE] Deprecate and remove credit_string() function
#  * [DONE] Add (basic) math/comparison operators to currency class
#            (add more operators as needed)
#  * [DONE] Change purchase/sale DMs from lists to hashes to improve data
#            entry and validation
#  * [DONE] Regenerate cargo for sale weekly (and reset price adjustment)
#  * [DONE] Review Calendar increment scenarios, remove speculative options
#  * [DONE] Add 'wait a week' command
#  * [DONE] Add extended berthing fee mechanism
#  * [DONE] Add monthly loan payment
#  * [DONE] Add monthly crew salaries
#  * [DONE] Protect input from bad data - one example, non-numeric
#            values cause crashes
#  * [DONE] Extract confirmation input loop to a reusable function
#  * [DONE] Display current date
#  * [DONE] Add fuel system to Ship
#  * [DONE] Add refuelling costs at starport
#  * [DONE] Restructure payment flow & dependencies for fuel
#  * [DONE] Add starport classification to StarSystem
#  * [DONE] Pass Credits in to Cargo ctor, not integer that needs conversion
#  * [DONE] Add fuel level check before executing jump
#  * [DONE] Add gas giant presence to StarSystem
#  * [DONE] Add view StarSystem data action
#  * [DONE] Skimming as jump point action, assuming gas giants present in 
#            StarSystem (abstract the outer system for this purpose)
#  * [DONE] Add 'plus days' method to ImperialDate (went with dunder again)
#  * [DONE] Create an unload_cargo method to consolidate proper handling
#  * [DONE] Add crew skills and their influence on sale prices
#  * [DONE] Add brokers and their influence on sale prices
#  * [DONE] Add display of ship characteristics
#  * [DONE] Prevent immediate resale of bought cargo
#            (current solution just prevents sale to source world, may want
#             to add a time element - simplest would be to reset the source_world
#             field to None, but later for Merchant Prince we may want to retain it)
#  * [DONE] Separate code out into modules
#  * [DONE] Review interpretation that skills/brokers only apply to sales - yes
#  * [DONE] Review Calendar.year() setter for whether it should notify observers - yes
#  * [DONE] Make StarSystem.__eq__ more robust
#  * [DONE] Add ship streamlining and effect upon landing/skimming
#  * [DONE] Add life support system to Ship
#  * [DONE] Add life support recharging costs
#  * [DONE] Check life support level before jump
#  * [DONE] Add fuel level check before travelling to jump point
#  * [DONE] Add life support expenditure
#  * [DONE] Add fuel expenditure
#  # [DONE] Unit tests for ImperialDate
#  # [DONE] Add test suite
#  # [DONE] Unit tests for Credits
#  * [DONE] Add maintenance availability to StarSystem (A + B starports)
#  # [DONE] Unit tests for Cargo
#  * [DONE] Add annual maintenance
#  # [DONE] Unit tests for Ship
#  # [DONE] Unit tests for Calendar
#  * [DONE] BUG: price array isn't updated when we remove Cargo from the Depot
#  # [DONE] Unit tests for Financials
#  # [DONE] Unit tests for StarSystem
#  * [DONE] Longer intervals need to make sure repeating events execute multiple times
#  # [DONE] Unit tests for utilities
#  # [DONE] Unit tests for CargoDepot
#  * [DONE] Advance calendar for in-system activities
#  * [DONE] Review need for fractional credits ('cents') - not needed
#  * [DONE] First pass pylint cleanup
#  PHASE TWO =======================================================
#  * [DONE] Basic StarMap class with coordinate & distance functionality
#  * [DONE] Add select destination before jump (will tie in to subsector map,
#            world generation, possibly freight & passenger selection)
#  * [DONE] Flesh out jump action sequence
#  * [DONE] Fix handling of observers after jump
#  * [DONE] BUG: Command messages not displaying correct world post-jump
#  * [DONE] Thoroughly test jump scenarios, verify location is changed everywhere
#  * [DONE] BUG: StarMap.get_systems_within_range is returning only systems AT range
#  * [DONE] Set starting location to StarMap origin point
#  * [DONE] Move Command message into game methods
#  * [DONE] Examine observers post-jump (depot especially) to verify correctness
#  * [DONE] BUG: maintenance date discrepancy between Financials & Ship
#  * [DONE] BUG: possible to be at jump point with zero fuel, and travel inbound to -5 fuel
#  * [DONE] Color initial command message string to make it stand out
#  * [DONE] Validate coordinates in StarMap ctor before building dictionary
#           (is this YAGNI? think we will need if we have manual input of star map data)
#  * [DONE] BUG: inbound fuel check too strict, can't travel in post-jump
#           (fixed - but should we do the same for outbound? as long as there is
#            a gas giant it would be fine, but otherwise player can get stranded
#            potentially...)
#  * [DONE] Calculate three-axis coordinates surrounding an origin hex at given range
#  * [DONE] Implement JIT world generation to populate an 'infinite' map
#  * [DONE] World strings should include coordinates
#  * [DONE] Verify map persistence
#  * [DONE] Add command to list out the star_map
#  * [DONE] Create a StarSystemFactory (we still want to be able to directly
#           create a world via params, so don't want this in the ctor)
#  * [DONE] Handle UWP formatting issue with 'hex' codes. Should we have a class?
#  * [DONE] Write up a manual test script
#  PHASE THREE =====================================================
#  * [DONE] No fuel should be available at E & X starports
#  * [DONE] Generate new star systems when jumping in, rather than
#           when jumping out as in current implementation
#  * [DONE] Assess whether a '2d6' method, or variable number of dice, is useful
#  * [DONE] Add Freight class
#  * [DONE] Unit tests for Freight
#  * [DONE] Add a destination flag to the Ship as aid for freight/passenger procedures
#  * [DONE] Only show matching destination when re-entering load_freight() if freight
#           already loaded
#  * [DONE] Finish unload_freight() method
#  * [DONE] Issue warning if jump destination does not match Ship.destination
#  * [CUT ] Should we automatically exit freight loop if none left will fit in hold?
#  * [CUT ] Should we allow putting freight back?
#  * [DONE] Freight should be blocked (or better, filtered) when selling cargo
#  * [DONE] Test sell_cargo() filtering with discontinuous list
#  * [DONE] load_freight() corner case: running on destination world before offloading,
#           so flag is still set
#  * [DONE] unload_freight() corner case: destination set but no freight on board
#  * [CUT ] unload_freight() corner case: freight for different destination on board
#  * [CUT ] unload_freight() corner case: freight for multiple destinations on board
#  * [CUT ] multiple destinations is tricky... in that case, what should the field
#           be set to? And if you offload one set, how does the field look afterwards?
#           But we ruled this out earlier, right? Implicit expiration date on shipping?
#  * [DONE] load_freight() corner case: 0 tons freight selected
#  * [DONE] sell_cargo() corner case: trying to sell with empty hold (or just Freight)
#  * [DONE] BUG: when overriding freight destination list due to flag, a non-reachable
#           world can be selected. Need an intersection between flag and list instead.
#  * [DONE] Add __hash__ dunder to StarSystem to allow placement in sets
#  * [DONE] Consider making the destination flag a dynamic query property instead, based
#           on contents of hold/passenger compartment
#  * [DONE] Add unit tests for Ship.destination property
#  * [DONE] Hide all StarSystem() ctor calls behind StarSystemFactory
#  * [DONE] Move destinations into StarSystem class
#  * [DONE] Should populate the map for the starting world at launch. Currently
#           hasn't mattered due to jump-1 ship we're testing, but change to
#           jump-2 and observe that neighbors aren't generated until the
#           jump command is issued.
#  * [DONE] Refactoring suggestion: we call get_systems_within_range() twice in Game.jump(),
#           once for (hopefully) pre-existing data, and once for the side effect of
#           populating StarMap.systems. Split this up.
#  * [DONE] Freight list per-destination should persist
#  * [DONE] Freight list per-destination should be refreshed weekly
#  * [DONE] Add freight shipping
#  * [DONE] Add passenger terminal: location, transition commands, command set
#  * [DONE] Add Passenger enum
#  * [DONE] Add refresh_passengers() and CargoDepot.passengers field
#  * [DONE] Add get_available_passengers()
#  * [DONE] Add book_passengers()
#  * [DONE] Add passenger manifest
#  * [DONE] Add Passenger class
#  * [DONE] Adjust destination property in Ship once we have passengers
#  * [DONE] Only show matching destination for freight if passengers already picked (destination
#           property ought to take care of this, check)
#  * [DONE] Disembark passengers when landing at destination
#  * [CUT ] Should we make contracted destination visible? Or is it apparent from
#           cargo hold and passenger manifest data? (Yeah, that's good enough for now...)
#  * [DONE] Reset destination flag when all freight & passengers offloaded (should
#           be handled automatically by destination property. Verify!)
#  * [DONE] Add passengers
#  * [DONE] BUG: if player selects freight (and passengers?) then does not confirm the
#           transaction, the items are still removed from the available freight list
#           (Passengers uses a tuple, which copies by value, not reference, so it is OK)
#  * [....] Consider asserts for constraint violations in freight logic especially. Should
#           not have a None flag if there is freight in the hold, and should not allow
#           freight for multiple destinations in the hold. (Property may take care of this
#           now. Verify!)
#  * [....] Truth table out the logic for combinations of cargo/freight/passengers/destination
#  * [....] Refactor freight/passenger methods, push down pieces as appropriate
#  * [    ] Review book_passengers() for behavior when passengers are already on board - 
#           should only be possible for same destination
#  * [    ] Passenger baggage allowance. From the hold or included in stateroom size?
#  * [    ] Add unrefined fuel and its effects (and query of StarSystem)
#  * [    ] Add misjumps and other ship malfunctions (ties to unrefined fuel & maintenance)
#  * [    ] Add crew members with skills
#  * [    ] Add proper salary calculation per crew member
#  * [    ] Add survival odds for low berth passengers, and report results each trip
#  * [    ] Add low berth lottery
#  * [    ] Working passage?
#  * [    ] Add mail? Usualy tied to Subsidised Merchants, which have a fixed route, so
#           not sure about this one.
#  * [    ] Add shuttles to surface (esp. for unstreamlined ships)
#  * [    ] Need to handle passengers if ship is unstreamlined
#  * [    ] Generate world names
#  PHASE FOUR ======================================================
#  * [    ] BUG: some payments don't check bank balance first - scrub & fix!
#  * [    ] Review world string UWP for errors, do we need an e-hex function?
#  * [....] Make type dunder methods more robust with NotImplemented etc.
#  * [....] Extend payment flow model to reduce coupling between classes
#  * [    ] Review (and possibly deprecate) item_number return value from CargoDepot.get_cargo_lot()
#  * [    ] Passenger selection interface is really tedious. Need some way to enter numbers
#           instead of choosing one at a time.
#  * [    ] Catch up test coverage, both for known/fixed bugs and methods & code paths
#  * [    ] Assess need to unset berth recurrence/expiry on takeoff
#  * [    ] Review observer tests for boundary values and long intervals
#  * [    ] pylint/pydocstyle scrub
#  * [    ] DESIGN ISSUE: single-letter commands are becoming too restrictive    
#  * [    ] DESIGN ISSUE: player can cancel and retry sale to get a better price
#  * [    ] Refactoring suggestion: have Ship own Financials (or other way around?)
#  * [    ] Refactoring suggestion: inbound/outbound methods in Game are almost
#           identical, and should be merged (consider fuel cost warning & stranding)
#           (Add another warning if fuel at 'stranding level' and no gas giant?)
#  * [    ] Should we have a 'stranded' condition? Pay for a tow truck?
#  * [    ] Review uses of die_roll and replace with multiple die functionality as necessary
#  * [    ] Need to be able to see maintenance date
#  * [    ] List star map to take a range parameter?
#  * [    ] Can we colorize current location in star map listing?
#  * [    ] Should we extract all the three-axis coordinate math to its own class?
#  * [    ] Lift all print statements out of model classes
#           (this might resolve the skipped tests - if not, that's a separate TO_DO)
#  * [    ] Learn how to use mock.patch to deal w/ side effect testing (stackoverflow 21046717)
#  * [    ] Review applicability of dataclasses/namedtuples (stackoverflow 47955263)
#  # [    ] Break up Game class (MVC?)
#  * [    ] Review flow, confirmations, notifications - streamline where annoying,
#           slow down where mistakes happen
#  * [    ] Assess whether rounding in Credits ctor can cause errors
#  * [    ] Replace dummy/test data with 'real' values
#  * [    ] Consider moving tests to separate modules
#  * [    ] Shotgun surgery between starting commands and star system detail setting
#  * [    ] Move cargo data to separate data file
#  * [    ] Should we add type annotations?
#  * [    ] Add visualization of cargo purchase DMs (colorized trade codes?)
#           (should be able to view in hold and while trading,
#            possibly also while choosing a destination world)
#  * [    ] Add a 'shore leave' action?
#  * [    ] Ships with better than jump-1 should be able to choose short jumps too.
#  * [    ] Rather than having up-front tests, make some commands dynamically
#           available in command lists when conditions merit - e.g. only present
#           skimming as jump point command if the system has a gas giant
#  * [    ] Tie-in with game over and save/load game - add front end with
#  *         restart / new game options, including re-using same star map
#  * [    ] Add out-of-funds condition (game over?) (Block in Financials?
#           i.e. balance can't go negative?)
#  * [    ] Save game state
#  * [    ] Load game state
#  * [    ] Should/could we clear the screen?
#  * [    ] Adjust UI elements, play with more ANSI codes - also review color
#           coding for warnings, positive/negative messages, etc.
#  PHASE FIVE ======================================================
#  * [    ] Implement coordinate conversion to Traveller subsector row/column
#  * [    ] 'Plot a route' functionality? Plan out a sequence of jumps?
#  * [    ] A world with: no gas giants, no hydrosphere, and starport E/X has
#           no fuelling options and is dangerous to travel to for normal 
#           commercial ships. Should flag this somehow. Mark red in listing?
#  * [    ] End game condition? In my recent test run, I arrived at an E-starport
#           world with no gas giant. It has a hydrosphere, but I haven't 
#           implemented wilderness refuelling yet. So my ship is stuck. Game Over?
#           Or add iceteroid mining as an extreme (and very lengthy) procedure?
#  * [    ] Add Navy/Scout bases to StarSystem? Only for color, yes?
#  * [    ] Should life support percentage be tied to 'days duration?' But what
#           happens if it hits zero?
#  * [    ] Set a 'visited' flag on StarSystem when jumping in? Might be needed
#           for perf as discussed above, but even if not I could see map displays
#           making use of it. Sort of a Fog of War mechanic. This may be as
#           simple as whether StarSystem.destinations is populated or not.
#  * [    ] Traveller '77 had route determination. Add this?
#  * [    ] Should freight expire or be assessed a penalty fee for late delivery?
#           Similar question for passengers. Particularly meaningful in the case
#           of misjumps.
#  * [    ] Review starport services, like life support recharge. Seems it
#           should be restricted like fuel is. None available at E/X?
#           Similarly, should a berthing fee be charged if there is no berth?
#           How about cargo, freight and passengers? Later Traveller editions
#           labelled almost all X starports as Red Zones (doesn't exist in '77).
#           E is not much better. No good reason for a commercial starship to
#           go there (though PCs are expected to be more adventurous of course).
#  * [    ] Think about guard rails. We don't want to go overboard. Learning
#           which choices are wise and which are foolhardy is part of the game. So
#           refuelling availability, low-grade starports, getting stranded - let the
#           player do that! Question is what happens then? Game over conditions,
#           penalties that let them keep going?
#  * [    ] Maintenance assists, plotting routes to service centers
#  * [    ] Should we allow partial fuel fillup?
#  * [    ] Ocean refuelling option if hydrographics permit it (should we then
#            split out another surface location? Implication of current 'surface' location
#            is it as the starport, which this is not. Scope creep, maybe hold this one
#            until phase five...
#  * [    ] Add extended StarSystem details
#  * [    ] Add different ship types and ship design
#  * [    ] Add a transaction ledger to Financial class
#  * [    ] Review need for negative or zero credits (balances and debts?)
#            Defer - currently all uses are positive, even debts, but haven't
#            implemented a ledger or more accounting features yet
#  * [    ] Add loan history and statement (amortization schedule too?)
#  * [    ] Distinguish between highport and downport
#  * [    ] RPG lite elements: named crew, brokers, color events & encounters, etc.
#  * [    ] Color: jump dimming
#  * [    ] If we want to expand beyond just the trade model, add 
#            ship encounters (Book 2 p. 36), hijacking, piracy, etc.
#  BEYOND ==========================================================
#  * [    ] Alternate shells: GUI, 'Oregon Trail style', etc. Would be amusing to
#            do ASCII graphics...
#  * [    ] Non-canon variations and features - draw from other RPGs, board games,
#           videogames, and brainstorming
#  * [    ] Other game modes, like Scouts - take a longer-range ship and explore.
#           Tweak world generation to produce frontier locations.
#  * [    ] Or cheats, like infinite money, free fuel, etc. (And actually a lot
#           of cheats start life as aids for testing. Might want a few of these to
#           help out as the game gets bigger.)
#
