# Trading procedure (Traveller 77 Book 2 pp. 42-4)
#
# Once per week, throw d66 to determine best cargo
#   DMs per world population
# Determine quantity
# Purchase if desired, up to limits of quantity
#   and available cargo space
# Partial purchases incur 1% fee
# Determine price of goods by 2d6 roll on table
#   DMs per skills, brokers, world characteristics
#
# Can sell cargo on a (different?) world
# Sale price by 2d6 roll on table
#   DMs per skills, brokers, world characteristics

# So overall sequence would be:
# Enter trade depot and see available goods
# Choice: wait a week, purchase some or all, jump to new system
# (And at any point can sell cargo in the hold)

# Other elements we will need:
#   time/calendar (so we will want to display current time...)
#   world characteristics
#   cargo tables
#   bank account (also need to display/query this...)
#   brokers for hire
#   character skills
#
# Not covered in this section, but eventually will want
# starship economics (Book 2 pp. 5-8)
# Operating expenses:
#   fuel
#   life support
#   routine maintenance
#   crew salaries
#   berthing costs
#   bank payment
#
# The starship economics section also covers freight
# shipping (flat rate - above is speculation) - add
# this option eventually. Also passengers.

# Ship design and customization is another potential
# area to explore. We'll assume a simple standard design
# (like the Free Trader) to start with.

# The star map will be a whole 'nother thing. A couple
# potential approaches:
#   Traveller subsector maps, whether generated or
#     loaded from a file
#   On-demand world generation - of course will need
#     to persist these systems as they are created

# UI thoughts:
#  as long as we're text-based, might want to play with
#  more ANSI code formatting to distinguish various things
#
#  also think about persistent display sections, rather than
#  always having to query data points
#
#  will need to make all the input much more robust - it needs
#  to handle bogus input appropriately

# -------------------------------------------------------------
# Comments about individual cargo unit_size assessment, prune
# through this and retain if any is useful...
# ---------------------------------------------------
# This data might belong in the cargo tables rather than here
# also, the RAW is very handwavy about tonnage for individual items,
# basically says "figure it out" - only some of these items
# are in the equipment list, so I'll fill in something plausible
# as best I can
# 
# Equipment list comparisons drawn from Book 3 (pp.16-7)
#
# Also need to consider that tonnage should be _displacement tons_
# not mass, so fiddle with the numbers supplied as necessary
# and there's packing material to consider too, as they call out in
# the example on Book 2 p. 43
#
# Per Traders & Gunboats p. 5, a 1.5m deck plan square, floor to
# ceiling, is half a displacement ton - so a 100-ton ship has
# 200 grid squares in theory. Yes, cargo hold ceilings might be
# higher than 3m, but this is a good enough basis for converting
# length/width into displacement numbers.
#
# Of course if we're dipping into sources later than the original
# three LBB, then we should be able to look all this up directly.
#
# Another observation - Traveller 77 trading setup does not consider
# Tech Level at all. Some of the items below might not be 
# producible on a given (low-tech) world. Can hand-wave by 
# assuming they are off-world products being warehoused here...
# 
# We'll assume the aircraft are less dense than the ground vehicles
# and fiddle with mass to volume ratios accordingly
#
# assume TL5 Fixed Wing Aircraft based on price
# weight 5 tons, cargo 5 tons, length 15m, wingspan 15m

# assume TL8 Air/Raft based on price
# weight 4 tons, cargo 4 tons
# the Scout/Courier deck plans in Traderes & Gunboats
# allocates 12 grid squares to its Air/Raft, so 6 d-tons

# not listed - base this on ship's computers
# closest fit is the Model/2bis, which costs a bit more
# (12MCr vs 10), and displaces 2 tons

# assume TL6 All Terrain Vehicle based on price
# weight 10 tons

# assume TL6 Armored Fighting Vehicle based on price
# weight 10 tons

# not listed, will need to guesstimate
# let's just assign it the same stats as ATV/AFV
# -------------------------------------------------------------

# -------------------------------------------------------------
# I'd like to ease the remaining coupling, don't like passing objects
# in to all the ctors, everything has access to everything. It's better
# than the previous global resource abuse, but could be better.
#
# The model I arrived at in Ship.refuel() may provide the way. It 
# handles its own data, then passes back the cost to the caller, which
# then passes it along to Financials. If we allow multi-dimensional
# costs (money, time, fuel, space), then the component classes could
# be properly ignorant of one another. Only the master Game class
# (which holds references to everything already) would know. This is
# something like a service bus - a blob of data flowing down a pipe,
# with individual components choosing whether to take action or not.
#
# Calendar (ImperialDate)
# ImperialDate
# Cargo (Credits)
# CargoDepot (Cargo, ImperialDate, Credits, Financials, Ship, StarSystem)
# Financials (Credits, ImperialDate, Ship, StarSystem)
# Credits
# Ship (Credits)
# StarSystem (Ship, Financials, CargoDepot)
#
# Should distinguish importing a class vs. calling methods or
# accessing fields on an existing object. The former is OK, the
# latter is coupling.
#
# The data classes (ImperialDate, Credits, Cargo) are fine, and
# right now Ship and StarSystem (with a minor exception) are in
# the same category. StarSystem owns CargoDepot - otherwise it
# is not coupled at all, so moving the latter up seems like a 
# good move.
#
# Almost all the logic outside of the master Game class is in
# CargoDepot, Financials, and Calendar. Those are the focus.
#
# So, after some initial shuffling, we now have:
#
# [OK] ImperialDate
# [OK] Calendar (ImperialDate)
# [OK] Cargo
# [  ] CargoDepot (Cargo, ImperialDate, Credits, Financials, Ship, StarSystem)
# [OK] Credits
# [  ] Financials (Credits, ImperialDate, Ship, StarSystem)
# [OK] Ship (Credits)
# [OK] StarSystem
#
# So, the model I think we're striving for is all actions involve
# invoking a series of sub-actions which return multi-dimensional
# costs, then passing the costs to the payees. Tempting to create
# a little class to represent costs, but that's overengineered at
# this point. Keep it to a simple tuple until we need more.
#
# Current actions:
#   quit
#   list commands
#   cargo hold contents
#   view world characteristics
#   wait a week
#   lift off to orbit
#   trade
#   refuel
#   go to jump point
#   land on surface
#   jump to new system
#   inbound to orbit
#   leave trade
#   show goods for sale
#   buy cargo
#   sell cargo
#
# There will of course be others, like skimming fuel, but these
# give a good sampling of what to expect. A few types:
#
# State transitions (quit, lift off, go to jump, land, jump, inbound, trade, leave)
#     Change state on object, may have a time cost
# Informational (list commands, hold contents, world chars., show goods)
#     Pull information from object
# Actions (wait, refuel, buy, sell)
#     Interact with objects, may have multiple costs
#
# These distinctions are pretty arbitrary, at least between the first
# and third. And in some ways even the second if you allow zero-cost as
# a thing. Anyway.
#
# So next step might be to make all actions (Command objects) correspond
# to a method on Game, and not allow them direct access to the child
# objects. Most pressing for buy/sell, but even the simple informationals
# should comply.
#
# Separating the child classes from interface actions (like print
# in the current UI paradigm) is also probably a good thing. They don't 
# need to know whether their output goes to the console or a
# GUI window. Be cautious of YAGNI of course. But still, if this is
# something like MVC, then the child objects are MODEL and shouldn't
# display anything at all.
#
# There are separate issues for the two classes still needing decoupling.
# CargoDepot is coupled in buy/sell cargo, which are both very long methods.
# Financials is coupled in notify and the tasks it calls.
#
# For the former, should break up the methods into small pieces (that
# still live in CargoDepot), then move the orchestration logic up to
# Game.
#
# For the latter, lift the observer up to Game - just add this logic in
# wait_week. At that point we only have one observer so the entire thing
# may not justify its existence, even though it isn't causing any problems
# in CargoDepot.
#
# OK. CargoDepot buy & sell have been broken up, and lifted into
# Game. This opens the door to removing references to Ship &
# Financials and fully decoupling the class. Methods of course will
# continue to slide around to appropriate homes as we go, but for now
# this is pretty clean. (I _do_ envision some sort of split of Game
# itself, possibly along MVC lines. We may end up pulling too many
# things up and that class will become bloated. One step at a time.)
# -------------------------------------------------------------

# -------------------------------------------------------------
# Another question is how to handle per-trip fuel costs.
# One model is to assess a cost for travel out to the
# jump point, and again for inbound. That does leave open
# the possibility of the ship being stranded.
# Alternative would be to assess the full trip cost on 
# landing.
# In both cases, there's the question of the player gaming
# the system and either evading costs or getting stuck.
#
# Could add a check before outbound to jump point that the ship
# has at least 2x cost (for there and back).
# -------------------------------------------------------------

# -------------------------------------------------------------
# We'll use the standard Imperial calendar, though that didn't
# yet exist in Traveller '77
# year is 365 consecutively numbered days
# date displayed as DDD-YYYY
# seven day weeks and four week months are used to refer to
# lengths of time, but rarely to establish dates
# (of course fun math, 7 * 4 * 12 = 336, so we are missing
# 29 days - but since week/month are really just durations
# it shouldn't matter)

# right now we only have refreshing the cargo depot weekly as an
# event, but there will be more:
#    * monthly loan payment
#    * annual maintenance
#    * monthly crew salaries
#    * daily berthing fees for extended stays
# other operational costs might better be handled as resource modeling:
#    * fuel
#    * life support

# also need to advance the calendar while in-system
# RAW says that ships typically take two trips per month:
# each jump is one week, and they spend a week buying & selling
# cargo, finding passengers, and on shore leave

# two approaches:
#    * give each action a cost in days
#    * advance the calendar only on jump and liftoff (the latter
#        perhaps with a message like 'you spent a week on Yorbund')

# for the former, does it add up to about a week? and do we want the
# player to be fiddling with time as well as money and space?
#    * to/from jump point - 1 day each
#    * to/from orbit - no time, don't want to privilege highport
#    * to/from depot/terminal - no time
#    * buy cargo (and load into ship) - 1 day
#    * sell cargo (and load into ship) - 1 day
#    * find passengers (and embark) - no time, changed my mind
#    * disembark passengers - no time (and no separate action)
#    * find freight (and load into ship) - 1 day
#    * unload freight - 1 day
#    * listing hold/depot/passengers - no time
#    * viewing ship/world/map - no time
#    * refuelling - no time at port, 1 day to skim 
#    * recharging life support - no time
#    * financial transactions - no time
#    * wait - 1 week
#    * maintenance - 2 weeks
#    * jump - 1 week
#
# easily 6-7 days if the player does all in-system activities
# but if they want to go fast, jump in, skim fuel, jump out - just
# one day? or even no delay if they have reserve fuel. (Life support
# is an issue under current implementation though.)
#
# Alright. I think I'll add time costs per the schedule above, and
# see how it plays. We're applying costs in the action methods in
# Game, so this should go there as well.
# -------------------------------------------------------------

# -------------------------------------------------------------
# Will want to consider what aspects of the starport to bring into
# play. Fuel availability for sure, as well as maintenance
# availability. Need to mull over minor damage and whether other
# repair facilities should be accounted for. Bases? Probably easy
# to add, have no real play effect, just color (could influence
# ship encounters, but even those are mostly color at least in the
# initial version). Ship construction is also for some future 
# version, if ever.
#
# Interesting that starport has no impact on trade. You'd think
# that an E or X class at least has minimal to no cargo available.
# But let's not critique the system just yet. I'll fill in ambiguous
# areas as needed, but otherwise keep to RAW. Later maybe we'll
# explore other editions and/or homebrew our own trading rules.
# -------------------------------------------------------------

# -------------------------------------------------------------
# Sketching out annual maintenance procedure.
# Book 2 p. 6
#   Annually, a starship should be given a complete overhaul...
#   Such maintenance costs 0.1% (1/1000th) of the cash price of the 
#   ship, and requires two weeks at a class A or B starport...
#   Crew members generally take their vacation at this time, but 
#   must still be paid. Provision should also be made for the 
#   expected loss of revenue while the ship is out of service.
#
# So, I think to start with, we flag the ship with a 'last 
# maintenance date' - use the start point of that two week
# period.
#
# Then we should be able to calculate 'days since last 
# maintenance.' This function will need to know ship maintenance
# date as well as current date. Model we use in Financials
# for other expenses (invoked from Game) ought to work.
# 
# May want to report on maintenance age, at least when it starts
# approaching a year. (Exact date ought to be visible all the 
# time from ship details.) Something like:
#  GREEN - maintenance less than 10 months ago - don't report
#  YELLOW - maintenance 10-12 months ago
#  RED - maintenance more than 12 months ago
#
# Financials already has a reference to ship that I have not
# refactored away. Intended to do that, so adding the method
# there is a bit backward, but whatever model we decide to 
# decouple will apply here too, so no real harm. (There is some
# logic to tightly binding Financials and Ship as well, so
# perhaps one should own the other. Later refactorings will help
# suss this out.)
#
# At least two mechanisms from there:
#  * if maintenance status is RED, there is a chance of drive
#    failures and/or misjumps (Book 2 p. 4)
#  * we'll need a 'perform maintenance' action at starports, which
#    advances the calendar two weeks, charges the appropriate cost,
#    and resets the maintenance date on the ship. Since it can
#    only be performed at class A/B starports, would be nice to
#    have this command dynamically available, but if not, it should
#    block at inferior sites.
#
# Beyond that, if we want to get fancy, would be nice to provide
# some assists to the player. They will want to know how far the
# closest A/B starports are, and gauge travel times.
# -------------------------------------------------------------

# -------------------------------------------------------------
# Reviewing the calendar observers. There are a couple goals:
# * Financials is coupled to Ship and StarSystem in notify. If
#   we remove or lift that, we'll only have one observer, so
#   the entire pattern is in question here. It may be 
#   over-engineered for the actual use case.
# * Feature-wise, we need to make sure that repeating events
#   (which is pretty much all we have) execute multiple times
#   if the duration is long enough. That doesn't seem to be
#   the case with the current implementation, though it's 
#   tricky to tease out. Maybe a mock observer and test case
#   to help peel it apart? But the solution may need to be
#   in the observer with current, because they know their
#   date and frequency.
#
# Observer test scaffolding is in place, so we can play around
# with this. But also, on reviewing, Calendar doesn't have a
# very clear reason for existing. It holds an ImperialDate, and
# a list of observers that it notifies upon change. Some of its
# logic duplicates functionality already in ImperialDate. And if
# we lift up the observer stuff to Game, there's not much here.
#
# Conceptually, a Calendar ought to hold _multiple_ dates, right?
# That's what makes it different from just a date. I think I was
# initially heading in that direction. So, whatever blob of code
# holds the observers should probably also hold their dates. Or
# to put another way, when an observer registers, it ought to 
# register the date that it cares about (or schedule? or 
# frequency?). That would bring the logic that decides how to
# fire actions in scope here, and not scattered across all the
# observer classes (we only have two right now, but anyway).
#
# Components of a schedule:
# * notification date
# * due date
# * recurrence
#
# Current (bugged) logic:
# 1) if notification date is later than due date, execute action
# 2) set next due date to last due date plus recurrence
#
# Should have a 'step 1.5' which is to calculate how many times
# to execute the action, based on the duration between notification
# and due dates. Financials.renew_berth() does that (though I'm not
# 100% sure it is fully correct; there's some odd 'renew for 6, renew
# for 1' behavior going on).
#
# Ah! Think I just spotted the bug in Financials...
# 
# OK. Fixed. But also, I now think 'due date' is mistaken. We should
# have 'paid up date' (whatever concise name should go here...). And
# due date is actually every _recurrence_ thereafter. These types of
# events, we're not providing an option to pay early, so they will
# always be on predictible days in the future. So calculate an integer
# division (_not_ modulus) and set the paid date to the last such, 
# and move on.
#
# I was able to test drive this design, and it looks correct so 
# far. Only problem is that the interesting code lives in my mock
# observer, not in calendar. So to implement for real, I need to 
# apply this design to all of the existing observers. And though
# there's only two subscribed classes, in some ways each event is
# one. Potentially worth extracting into a class. We will see.
#
# Almost done with this work. Turns out there are slight variations
# in the model. Also Financials is riddled with side effects that
# I will need to address, so while the tests work and helped to drive
# the code to a better state, I will mark them skip for now.
#
# We have a total of five observer events to deal with:
#  1) CargoDepot.notify() - to refresh cargo selection weekly.
#      Refreshes cargo weekly, but doesn't need to execute
#      multiple times, just once if duration has passed.
#  2) Financials.berth_notification() 
#      Two phases: first part on landing, with six-day coverage.
#                  then a daily renewal after that.
#  3) Financials.salary_notification()
#      Standard observer model with a 28 day recurrence.
#  4) Financials.loan_notification()
#      Standard observer model with a 28 day recurrence.
#  5) Financials.maintenace_notification()
#      No recurrence. Just calculates a duration and reports
#      status. Resetting the state is via a separate mechanism.
#
# The 'standard observer model' is:
#  Observer:paid_date
#  Observer:recurrence
#  Observer:notify(date)
#      duration = (date - paid_date) // recurrence
#      for i in range(duration):
#          execute_action
#          paid_date += recurrence
#
# All done with the initial set of tests. Need to review to make
# sure the date ranges chosen make sense - though the tests are
# passing, I'm not 100% certain I chose good boundary values. Also,
# might not have emphasized the whole 'repeat on long ranges' thing.
# Still, scaffolding in place for improvements.
# -------------------------------------------------------------

# -------------------------------------------------------------
# Working through the design for multiple star systems. A few
# considerations:
#
# * Basics. Traveller maps the universe on a 2D hex grid. One
#   hex is one parsec, with each hex either being empty or 
#   occupied by a single star system. In Traveller '77 these
#   are very rudimentary, with no stellar characteristics and
#   only the 'mainworld' described at all. The standard map
#   is an 8 hex by 10 hex subsector (all that exists in '77) - 
#   later these were grouped into larger sectors (4x4 subsectors).
#
#   At least for the initial version(s), I will maintain the 2D 
#   hex grid standard.
#
# * Coordinate system. To distinguish different star systems, and
#   to calculate distances between them, we need some kind of 
#   coordinates. The standard Traveller subsector assigns each
#   hex a row/column coordinate - so they run from 0101 through 
#   0810. In the expanded sector arrangement, they run from 0101
#   through 3240.
#
#   But these coordinates can be a PITA to work with for anything
#   but simple layout. Calculating distances between two arbitrary
#   hexes is rough, and you need a second square (well, rectangular)
#   grid coordinate overlaying it to handle crossing subsector
#   boundaries.
#
#   In a previous project, I came up with a three-axis system that
#   works pretty well. Distances are trivial to calculate (the 
#   highest absolute value of any of the three coordinates). There's
#   also an interesting checksum built in - if the coordinate is
#   valid, its three values sum to zero.
#
#   Expanding on that, I had considered a 'circular grid.' Rather 
#   than arbitrary subsector boundaries overlain on the universe,
#   each world can effectively be the center of its own subsector.
#   Some products used to publish 'jump maps' that take this view,
#   like all hexes within 4 parsecs of some central world.
#
#   But again, the goal for this first version is compatiblity with
#   Traveller '77 RAW, so we should use the three-axis system
#   internally, with conversion to the standard row/column format for
#   display. My previous project already worked out the math, so we
#   can lift it.
#
# * Canon. Touched on above already. I don't mean canon in terms of 
#   setting. Traveller '77 doesn't have one, which is part of its
#   charm (though a bit is implied by things like Credits, naval 
#   bases, and so on, the Imperium is never mentioned).
#
#   I more mean 'rules canon.' As great as Traveller is, there's some
#   very clunky or outdated ideas in there too. And it is mighty 
#   tempting to 'fix' them.
#
#   For now, resist the tempation. I could see a future version
#   of this (or a spinoff) going in a different direction. The round
#   grid mentioned above is one idea (or a 3D grid). Lots of drift
#   to be found in later Traveller editions, especially in world
#   building and astrophysics. And I have some ideas about how 
#   interstellar cultures could work too. But all that is later.
#   Stick to RAW.
#
# * Dynamic generation. OK, this is finally getting into _how_
#   we're going to implement this feature. There are a couple 
#   basic approaches I can see:
#
#   * Dynamically generate star systems on the fly as we need 
#     them. Of course we also want persistence, so once 
#     generated we need to be able to get them back. And 
#     persistence across game sessions is a consideration
#     too - is the universe gone once you quit, or can you
#     resume play in it? I think eventually I'd want the latter,
#     though we could defer until later.
#
#   * Have a pregenerated map to work from. In practice, I would
#     probably generate the map rather than just enter in the data
#     from a published source. (Though the latter has some appeal
#     too - tooling around in the Spinward Marches would be fun.)
#
#   I think dynamic will be simpler to get working. Most of the 
#   pieces built there will also be useful for map generation.
#   And once we get persistent saved games, that will help us
#   figure out file formats and so on for the data entry
#   approach.
#
# * Coding strategy. All that said, still not sure exactly how
#   to tackle. Tempting to sketch out a bunch of classes and
#   so on. But probably better to work from in-game use cases.
#   That's been the approach so far, and it seems good. As with
#   test driven design, each next step is small and pretty 
#   obvious, even when you don't quite know where things will 
#   end up.
#
#   So let's start from the 'jump' action in Game. Figure out
#   what's needed there, and build out piece by piece.
#
#   * We need fuel & life support costs, jump range, and time.
#     All that is in place already.
#
#   * If the ship qualifies (enough fuel/support, and at the 
#     jump point), show all systems in range. At jump-1, that's
#     at most six.
#
#   * For the initial bring up, we can have a stub that just
#     returns a single system. And it should be able to swap
#     back and forth between that and our original world.
#
#   * The new star system can be mock data added by hand. 
#     Later we'll have some facility for generating a new
#     world, or looking it up on the internal map.
#
#   * Player selects destination, confirm and go!
# 
#   * Any global references that are tied to location
#     need to be fixed up. Already have some comments about
#     the observers and the command set in the traveller
#     module; wouldn't be surprised if there are others.
#
#   * Last, now that we finally have a reasonably comprehensive
#     set of unit tests and good-ish hygiene, the new classes
#     should be developed test first as much as possible, and
#     conform to pylint feedback too.
#
# * Beyond that initial feature, we'll definitely want:
#
#   * Ability to see the star map somehow. Might be interesting
#     in a text interface... Optionally being able to render
#     out as a bitmap might be cool. Also need associated 
#     UI actions.
#
#   * Hints for the player about things like nearest maintenance
#     depot, where frontier fuelling is available, etc.
#
#   * Of course save/load of star map data, as mentioned above.
#     (And UI actions...)
#
#   * Things like misjumps need to be considered. In some ways
#     very easy if we assume three-axis coordinates and dynamically
#     generated universe.
#
# OK, after all that, I almost immediately went off course. It's
# obvious we'll need some kind of map class to manage all the 
# systems. So I made a StarMap class. And from there, I started
# some simple tests to drive a basic interface. And that's 
# ballooning a bit. The strategy above assumed more of a mock
# StarMap that would only allow us to bounce between two
# hard-coded systems, but I'm building something more 
# full-featured (though still pretty simple).
#
# Questions we'll need to address (more of them):
#
# * Container for star systems. Very straightforward, and on
#   its own not enough to justify a class. I'll use a dictionary
#   with the key being a coordinate tuple. Tempting to make
#   another little class for coordinates, but premature I think.
#
# * Coordinate system and 'space.' We need to be able to distinguish
#   separate star systems, to calculate distance between them, and
#   so on. Per the above, coordinate system will be three-axis. My
#   test driving right now is building up that functionality.
#
# * Travel basics. This is the section above. We can hard-code
#   a map of just two systems and then build up travel mechanics
#   until they're set.
#
# * Populating the map. Once that is all working satisfactorily,
#   we'll need to decide how to fill in the map. Since we want
#   dynamic, this will be a JIT system. Request a system by 
#   coordinate. If it's in the container, return it. If not,
#   generate it.
#
# * Generation of star systems. Finally, we'll need to be able
#   to create new systems on the fly. Initially we'll just have
#   hard-coded values, but will need to create for real 
#   eventually. Traveller world generation procedures are 
#   easy to implement, so not a big deal. World name generation
#   may be the most interesting part.
#   
# First two above are basically done. May be tweaks later, of
# course. Time to work on travel mechanics.
#
# Travel is working! We can finally move between systems and
# trade goods. The basic game flow is working. Lots of polish
# and little features to add from here, of course. I want to do
# a little more testing and handle some rough edges spotted
# during playtest, then we'll get the JIT generation up and running.
#
# For JIT, we need a few things:
#
# * First, the methods in StarMap need to accommodate a 'None'
#   entry in the system dictionary.
#
# * Second, we need to be able to calculate coordinates relative
#   to an origin. We can handle distances, but generating new
#   coordinates, not quite yet. One approach is to handle
#   as a set of translates - for example, extending the axial
#   rows is as simple as repeatedly adding the appropriate
#   edge hex from the first ring. And the hexes in-between are
#   a combination of translates along two axes.
#
#   Another observation is there are axis rows, and six 'pie
#   slices'. At a given range, there are exactly six axis hexes,
#   and (range-1)*6 edge hexes.
#
#   And another - if you look at a diagram and figure out a 
#   given edge hex's coordinate (axis hexes are trivial), stepping 
#   along the two axis rows that bound its slice and adding those
#   two axis hexes together gives the result, just like with
#   Cartesian coordinates. So you just need to keep track of
#   which two axes govern that slice. (And of course adding
#   two coordinates together is basic vector translation...)
#
#   I have this working for everything except the edge hexes. Need
#   to work out the formula. But another idea occurred to me. What
#   if we just create the full set of potential hexes based on range,
#   then eliminate the invalid ones? Tempted to do this and see
#   which is more performant. I think this new idea would be less
#   code at a minimum, and probably easier to comprehend, than 
#   some geometry-based logic.
#
#   As it turns out, the list comprehension approach was very
#   easy to build and verify. And certainly less code overall.
#   Probably more readable too as long as you're comfortable with
#   the syntax. I stripped out all the geometry-calculating
#   methods. Maybe sometime it would be interesting to figure
#   out, and I suppose there's a theoretical performance
#   question to understand, but at the scale this program is
#   working, I don't think it's meaningful. I hope. Stress test 
#   with a _really_ big map? What's the big-O for my algorithm?
#   There is a cube of range involved in get_all_coords(),
#   which makes me a bit leery. We probably only ever run
#   it with small numbers. Jump-6 is the maximum in Traveller,
#   and a reasonable maximum for grabbing a bunch of coordinates
#   all at once. We'll keep an eye on performance and see.
#
#   OK. Tried out a jump-6 ship, and the current implementation
#   generated 60+ worlds in an eyeblink. No observable
#   perf issue at this scale (and per Traveller canon, jump-6
#   is the largest possible. Mijumps don't count for this
#   purpose.) So practically speaking, we're good.
#
# * That done, the last bit is easy: get_systems_within_range()
#   should look at all hexes by coordinate, not by what is present
#   in the dictionary. An if a given coordinate is not in the 
#   dictionary yet, generate it. The result will be either
#   None or a StarSystem.
#
# All this is working. The map is effectively infinite, with 
# new systems being added around the edges as needed. Right 
# now they're all hard-coded to a test value. Need to create
# some kind of factory to build them. But it works!
#
# I did a bit more validation, and some manual testing flying
# around this little galaxy. It pushed me to implement some
# better visibility into the map, so coordinates are now shown
# when printing StarSystems, and we have a command to dump out
# the entire map at will. It is persistent within a session - 
# I can travel across the map and back, and still see the same
# (generated) systems in the same places. On to world factory.
#
# And we're done. Infinite map with real Traveller worlds. I
# still don't have a naming system in place, but the data looks
# good and everything appears to be working correctly. This is
# MVP. I want to capture a manual test script before moving on,
# and take closer look at a few things, like dates and map
# structure. Then we can add minor features, color, and polish.
#
# Test plan is complete, and after playing around a bit, 
# things look correct. Only issues I've spotted so far are
# expected design issues I haven't gotten to yet. I also 
# scribbled on a map, and the generated 'galaxy' hangs 
# together properly, with persistence and adjacency as
# expected.
#
# One tweak I want to make next: it makes sense to generate
# worlds when jumping _in_ to the system. It's like being
# able to see immediate neighbors, and will be necessary when
# generating freight/passengers anyway. Current implementation
# only does this when we attempt to jump _out_.
#
# Problem is that calling get_systems_within_range() is the way
# to do this, and is proper whether or not neighboring systems
# have already been generated. But regardless of which, it will
# always call the potentially-expensive get_coordinates_within_range().
# At the jump-1 scale I'm currently testing this is not an 
# issue, but per the perf discussion above, maybe it will be?
# Need to profile and test of course. And if it _is_ an issue,
# we could always set a 'visited' flag on the system so we 
# don't run it again. 
#
# Ah, with a bit more thought... the second call to the method
# is really for its side effect, and the first call hopes
# it has already been called. So maybe this should be split up?
#
# And yet another thought. If we split it up, the pre-jump
# version would just dump out the contents of StarMap.systems,
# filtered by range from origin. Danger there is if current
# world is somehow not 'visited' this list would be incomplete
# and could change later. (Not sure how we'd get into this state,
# just spitballing.) To protect, I suppose we could return
# all systems, including None, and validate return list length
# by an easily calculable 'hexes within radius' formula. Then
# filter out None before displaying. Meh, probably too much
# fiddling.
# -------------------------------------------------------------

# -------------------------------------------------------------
# OK, next up is freight and passengers. Let's tackle freight
# first. It piggybacks on cargo somewhat, and the rules state
# passengers present themselves _after_ a freight destination
# has been chosen.
#
# First, the basic procedure per the rules (Book 2 p. 7):
#
#   The referee should determine all worlds accessible to the 
#   starship (depending on jump number), and roll (for each such
#   world) a number of dice equal to the population number of the
#   destination. Each die represents one shipment, expressed in
#   multiples of 5 tons... A starship can carry as many shipments
#   as will fit in the hold, but may not break down the size of 
#   any specific shipment... Cargo is normally shipped at a rate
#   of CR 1000 per ton.
#
# So, some observations:
#
# * It's implied that these destinations are all one jump away,
#   so hopping across several connections is not OK. The shipper
#   would just select a higher-jump transport.
#
# * Continuing from that point, there's a time limit, meaning
#   the player cannot select cargoes from more than one world.
#   They never state this explicitly, but it reads that way to
#   me. The text of the passengers section reads similarly.
#
# * I've already established that cargo loading takes one day;
#   the same should apply here. But! This should not be per
#   shipment. The player should be able to select several
#   shipments, then one day passes for them all to be loaded.
#
# So, roughing out the steps and pieces we'll need:
#
# * Obviously a 'load freight' command from the trade depot.
#
# * And by implication, an 'unload freight' on arrival. This
#   one will be comparatively simple. Just time and payment,
#   and removing from the hold.
#
# * After executing the command, show a compound list:
#
#   * Headings are worlds within range
#   * Entries within each heading are shipments, just tonnage
#
# * Not sure yet how the interface should work. Select a world
#   first, then prompted to pick shipments (displaying total
#   size and remaining space each time), followed by a 'load'
#   to wrap up?
#
# * Of couse the player should be able to cancel out at any
#   point with no penalty. They have to be able to browse.
#
# * Loaded freight will appear in the cargo hold. Not sure if
#   we can overload the Cargo class to handle, or will need
#   something else. Freight only has three data points: source,
#   destination, tonnage. (Date and expiry? Check later rules
#   for embellishments, down the road.)
#
# * Another blind spot in the rules: how often is the freight
#   list refreshed? Seems simplest to align with cargo. Every
#   week there's a new bunch of freight. And of course we need
#   to maintain the list between refreshes.
#
# * Freight should be blocked (or better yet hidden) from the
#   'sell cargo' procedure.
#
# * Interplay with passengers is interesting. That procedure
#   (we'll get to in a bit) states to generate passegers for
#   the selected freight destination. But what if there isn't
#   one? Player either doesn't want freight, or does passengers
#   first? In this (freight) procedure, we only need to worry 
#   about the second option. Should we restrict the freight 
#   list if passengers have bought tickets for a destination?
#
# Basics are working here. The load_freight() method is a bit
# hairy, so will need cleanup. And I'm discovering lots of
# corner cases, playing a bit of whack-a-mole.
#
# -----------------------------------------------------------------------------
# destination           freight in hold       passengers       
# -----------------------------------------------------------------------------
# None                  No freight            None            OK
#                                             Local           BUG - flag mismatch
#                                             Other           BUG - flag mismatch
#                       Local                 None            BUG - flag mismatch
#                                             Local           BUG - flag mismatch
#                                             Other           BUG - flag mismatch, diff. dest.
#                       Freight - other       None            BUG - flag mismatch
#                                             Local           BUG - flag mismatch, diff. dest.
#                                             Other           BUG - flag mismatch
# Contract = local      No freight            None            BUG - flag mismatch
#                                             Local           OK
#                                             Other           BUG - flag mismatch
#                       Freight - local       None            OK
#                                             Local           OK
#                                             Other           BUG - diff. dest.
#                       Freight - other       None            BUG - flag mismatch
#                                             Local           BUG - diff. dest.
#                                             Other           BUG - flag mismatch
# Contract = other      No freight            None            BUG - flag mismatch
#                                             Local           BUG - flag mismatch
#                                             Other           OK
#                       Freight - local       None            BUG - flag mismatch
#                                             Local           BUG - flag mismatch
#                                             Other           BUG - diff. dest.
#                       Freight - other       None            OK
#                                             Local           BUG - diff. dest.
#                                             Other           OK
#
# Constraints on freight (and by extension passengers):
#   * Destination flag must be set if there is freight and/or
#     passengers on board
#   * All freight (and passengers) are for the same destination
#   * Destination flag must match freight/passenger destination
#
# Could/should the flag be dynamic, set via query property? Yep.
# Seems to be an improvement.
#
# Almost done with freight. The last significant piece is making
# the freight list persistent. Currently it's refreshed every
# time the player invokes the command. They could game the system
# by repeatedly spamming and exiting to get exactly the freight
# they want. Not a game-breaker I suppose, but it's also
# 'unrealistic.' Freight, just like cargo, should show up
# more slowly.
#
# Another benefit is this is pushing me to refactor the ugly
# load_freight() method. I conciously put that together all
# in Game, knowing it would need cleanup once I understood
# the flow.
#
# That's progressing but I'm on the threshold of a slightly 
# larger change. Freight needs to know about destinations.
# Currently I am only generating destinations in three
# places - twice in jump() and once in load_cargo(). And 
# the only place the information is persisted is the 
# StarMap dictionary. I think it would be helpful if
# StarSystems knew their 'neighbors.' Yes, this is specific
# to the ship in question, not the StarSystem proper, but
# I don't envision any way for the player to change their
# jump capability for a long time, if ever.
#
# So, seems like rather than in jump, we should generate
# when we create the System. If we do it in the ctor, we'll
# need to couple too many things IMO. But how about in
# StarSystemFactory? For that to work, we'll first need
# to get rid of any 'bare' invocations of the StarSystem
# ctor. Another method that allows us to specify the 
# attributes, rather than rolling randomly, should do the
# trick. Let's go.
#
# There _is_ a bit of chicken and egg going on with destinations,
# at least for the first few worlds. If we add them in a batch
# (as we're currently doing for our test galaxy), then we can't
# generate destinations world-by-world, or we'll get discrepancies.
#
# We may need two different approaches:
#
# * When batch creating worlds, iterate through and generate _after_
#   the batch is created. (Is the thumbprint here the StarMap ctor
#   and/or StarSystemFactory.create())
#
# * When creating worlds individually, you can create at the same
#   time, as we're adding just the one to the map. But! There's an
#   infinite recursion lurking here. If we naively keep going back
#   to StarSystemFactory.generate(), and it keeps calling itself,
#   this will blow up. We need a base case. That may be based on
#   'visited' (new flag, just spitballing). We only generate
#   destinations for visited worlds. But doesn't that put us back
#   to the current implementation? Generate when we jump in?
#
# OK. So the StarSystemFactory changes we just made are fine. Don't
# think we need to revert. But that's _not_ the place to generate
# destinations. It's when we jump in. (This also circumvents the
# whole 'if the ship changes' theoretical problem, as it is
# directly tied to a Ship instance making a jump.)
#
# In that case, we're almost there. Jump is already calling this,
# and by definition we need to have jumped to a world before
# entering the trade depot. So we're covered (for everything but
# the starting world...). Just need to have the work done in
# Game.jump() preserve its data in the StarSystem class.
#
# -------------------------------------------------------------

# -------------------------------------------------------------
# OK. Freight is done. Still needs more refactoring and some
# careful testing, but unit tests and manual test runs look good
# so far. Time to sketch out Passengers.
#
# Rules procedure (Book 2 pp. 7-8):
#   After a starship has accepted cargo for a specific destination,
#   passengers will present themselves... Consult the passenger
#   table: roll the number of dice specified in the originating
#   world column. From the result, add or subtract the stated 
#   number in the destination column. Roll separately for high,
#   middle and low passage. Treat worlds of population level
#   greater than 12 as level 12. (NOTE: this ruleset cannot 
#   produce worlds with population > 10)
#
#   Passengers will pay the standard fare for the class of
#   tranportation they choose (CR 10,000 for high passage,
#   CR 8,000 for middle passage, CR 1,000 for low passage).
#   Passage is always sold on the basis of trasport to the 
#   announced destination, rather than on the basis of jump
#   distance.
#
# First, thematically I think passengers should not come from
# a CargoDepot. Functionally they may be the same thing, but 
# there ought to be a Passenger Terminal. Both a class (analogous
# to CargoDepot, and possibly functionally identical), and a
# location just like 'trade depot.' So step one is to 
# stub out the state transitions and class.
#
# Second is timing. Seems like the player could sign up 
# passengers at any time. From the POV of the passengers,
# they want to know a departure date, and won't board
# until then. Low-berth passengers could take some time to
# load, but the others ought to be a fairly short affair, so
# not sure we should assess a time penalty here. The player
# chooses passengers for a destination (which may be restricted
# if they are already under contract for freight), and they 
# are considered 'loaded' immediately (not sure it's worth 
# the hassle of signing them up, then only changing the manifest
# just before launch... would mean too many fiddly steps for the
# player to deal with).
#
# Similarly, the passengers will want to disembark immediately
# upon arrival at their destination. For color, in the offload
# message we can have something about going to the passenger
# terminal, but I don't think the player should have to 
# invoke this. It should be automatic on landing (or docking
# with high-port, once we have that) much like assessing
# berthing fees.
#
# But what about low berths, and the low lottery? Hrm. Should
# we separate walk-on passengers procedure-wise?
#
# OK, so assume all that is sorted. We can load and unload 
# passengers, and presumably get paid at the destination.
#
# We'll need some sort of structure to store the passengers,
# and distinguish between the categories. A very simple scheme
# would be a flat list with entries of H/M/L. We'd need integrity
# checks to make sure these don't overflow the available space.
# And we want to be able to report on occupied berths. (Long
# term color, having named passengers would be nice. And there's
# the question of potential hijackers too...)
#
# I've settled on a tuple for passenger counts, and an enum
# to index into it. Seems simple enough. We may need to expand
# to a full class later if we add names and so on, but right
# now a passenger is a very simple entity, much like freight.
# (Though come to think of it, just like freight they also may
# need to track destination, or we need to account for it somehow
# for the destination property to work. Currently I just track
# counts by passage type. This will evolve.)
#
# OK, yeah, destination is a stick in the spokes. Plus the
# enum syntax isn't as smooth as I'd hoped. To use as an
# index into the tuple you need to access the value field.
# It's very verbose and feels like I'd be better served with
# a few constants. But also, where to stash the destination?
# I toyed with a fourth field in the tuple, but that causes
# issues when we zip them up for tuple element addition. I
# think we should have a Passenger class similar to Freight.
# Figuring that out now.
#
# We'll also need a selection loop at the terminal similar to
# how freight works. Keep picking passengers until satisfied.
#
# Passengers might be more dynamic than freight. Not sure yet
# about how/when to refresh or persist the list. Though you 
# could imagine at a low-traffic world, the list is pretty static
# and the passengers may be forced to wait until transport
# comes through.
#
# So our flow is:
# * From the Starport, go to the Passenger Terminal.
# * If a destination has been contracted, use that, otherwise
#   allow choice just like with Freight.
# * Player is presented with a simple list of passenger
#   counts, by High/Mid/Low. And should also be able to 
#   see their available/occupied berths.
# * Player prompted to choose passengers. Not sure yet how,
#   seems awkward to ask 'how many High?', 'how many Mid?' etc.
#   But don't yet see a slicker way to get the input (at least
#   in a text-based UI).
# * As with Freight/Cargo, will need to reject selection
#   if there isn't enough space left.
# * Once passengers are committed, the passenger manifest is
#   updated and the destination is set if not already. Same 
#   integrity constraints here as Freight. Manifest needs
#   to show destination.
# * All this takes no time. Assumed that passengers are loaded
#   before launch. In fact we probably should add a message
#   to the launch command if any passengers have booked.
# * Then the ship proceeds to jump and heads to destination.
# * Same considerations as Freight. But even more so - Passengers
#   will not be happy if the ship doesn't go directly to the
#   destination. Think about the penalty suggestion here.
# * On arrival and landing at the destination, passengers
#   automatically disembark, and the player is paid. Message here
#   too to that effect.
#
# Actually seems pretty simple, since we've worked a lot of
# this out in Freight already. We'll see as we dig in.
#
# Lots of room for color with Passengers, of course, as 
# mentioned already. Names, personalities, events, RPG stuff.
# Could have random chance of long-haul passengers (which would
# change the algorithm a bunch, since we're constraining both
# Freight and Passengers to a single one-jump destination at
# present). Hijackers too (which has a small system in RAW
# to piggy-back off of).
#
# -------------------------------------------------------------

# -------------------------------------------------------------
# Since it actually has a rules procedure, the first bit of
# passenger 'color' is low berth fatalities. From Book 2 p. 2:
#
#   Unfortunately, the low passage system involves some intrinsic
#   dangers... Throw 5+ for each passenger, when he is revived
#   after the ship has landed. DMs: attending medic of expertise
#   2 or better, +1; low passenger with an endurance of 6 or less,
#   -1. Failure to achieve the throw to revive results in death...
#   Refunds and civil or criminal liability if a low passenger
#   fails to survive the trip are not allowed.
#
# Ok, so two bits to defer until later are medic skill and 
# passsenger endurance (though the latter would be pretty
# easy to add in...).
#
# The player gets paid regardless, so this should be a simple
# check against all low passengers at disembarkation, and
# reporting the results. Low lottery will add a bit more
# spin to this feature...
#
# Low berth survival is done (including endurance, but not medic
# just yet). So how about the lottery?
#
# Book 2 p. 3
#   It is customary for the captain to contribute CR 10 out of
#   each low passage towards a lottery in which each low passenger
#   randomly guesses the number of low passengers who will
#   survive the trip. If the winner does not himself survive,
#   the captain receives the money.
#
# So, easy enough to generate a random number and attach to each
# Passenger. But timing... They should be guessing against
# the entire contingent, at least as of the time they board. So
# not when they are created (in book_passenger()), but when
# the ship takes off (in liftoff()).
#
# Then we'll also need to tweak the survival logic. Right now
# we just filter down the low passenger list, so there's no
# way to check the corpses to see if they have the winning number.
# And we can only know the winning number after the survival
# procedure has run.
#
# (Also, seems implicit that a winning guess has to be exact,
# not 'closest,' or the clause about the captain wouldn't be
# necessary.)
#
# OK, first up is "guess survivors" in Passenger, called from
# liftoff(). Got it. Now to adjust the survival calculation,
# and the payout. And done.
#
# -------------------------------------------------------------

# -------------------------------------------------------------
# Next up, we need to make a decision about passenger baggage
# allowance. The rules are vague, and checking later versions
# doesn't really clarify. Some of them hint that the passenger
# cargo _might_ go into the hold, but not explicitly. So I think
# I'll rule that high passengers (only) get 1 ton of cargo each.
# The other types fit in their stateroom, or in a locker in the
# cold sleep room.
#
# OK, so we'll need to wire this up in book_passengers(), block
# booking any high passengers if no more room, and also have
# a cargo entry so the math on that side works out correctly.
# We also need to unload baggage when the passenger disembarks.
# Not worth the effort at this point to link a specific
# passenger to specific baggage, they're all just generic items.
#
# -------------------------------------------------------------

# -------------------------------------------------------------
# I just added fuel quality. From A/B starports, it's refined,
# and from C/D (as well as gas giant skimming), it is 
# unrefined. My system is to flag the fuel quality on the ship.
# The flag changes either when putting unrefined in the tanks,
# or when emptying them completely.
#
# Book 2 p. 4:
#   If unrefined fuel is used, there is a chance that the drive
#   will fail while in flight (throw 11+ for failure to occur,
#   throwing once per jump in which unrefined fuel is used, DM 
#   +1 for each jump made, until the drives are flushed, which 
#   takes about a week at any starport).
#
# This is rough. A wise captain should avoid C/D starports 
# entirely, to be honest (and E/X as well).
#
# Check later rules to see if they are more relaxed about it...
# OK, flushing the tanks was dropped in Traveller '81 and I
# don't see it reappearing in later editions. Traveller '81
# also hints at 'drives made for unrefined fuel' on military 
# starships. High Guard introduced fuel purification plants.
#
# Well, let's go RAW and add the 'flush' command. We can
# always change it later to something less punitive. I think
# the more dramatic result is interesting for a videogame
# anyway. This becomes almost rogue-like if there's failure
# conditions around every corner.
#
# That done, let's figure out the effects bit. This will also
# interact with ship maintenance. Effects are drive failure
# and misjump. Will also need to have some way to fix.
#
# Book 2 p. 4 again (section above covers fuel.):
#   Throw once per jump made after annual maintenance has
#   been skipped: a result of 12 indicates drive failure...
#   When a drive fails... they may be temporarily repaired
#   by engineer crew members (throw 10+ to repair, once per
#   day; allow DM of +level of engineering expertise...). More
#   comprehensive repairs are then made at the next starport.
#
#   At the instant of jump, a jump drive which is a) within
#   100 diameters of a world or star, b) operating on unrefined
#   fuel, or c) operating without annual maintenance may
#   malfunction, resulting in a jump of random length and
#   direction.
#
#   For all jumps (in any situations), throw 12+ for a misjump
#   to occur. DM +5 if within 100 diameters of a world or star;
#   +3 if using unrefined fuel (except military and scout ships);
#   -1 if using refined fuel; +2 if operating beyond the
#   required date for annual maintenance.
#
#   A misjump involves a considerable random jump. Throw one
#   die to determine the number of dice thrown (1 to 6). Throw
#   that number of dice to determine the number of hexes long
#   the jump is. Throw one die to determine which of the six
#   directions on the hex grid the jump is made.
#
# So, from all of this, we will need:
#
#  * Counter for jumps with unrefined fuel.
#  * Check for drive failure at jump, affected by previous
#    and annual maintenance status.
#  * Check for misjump at jump.
#  * Ship 'needs repairs' status. Later rules indicate dead
#    in the water, but not so clear here.
#  * 'Repair' command, both on ship and at starport.
#  * Misjump destination calculation. Nothing says this has 
#    to be a world; could be deep space, in which case the 
#    ship is screwed... Would be more kind to always put
#    them at a world. We'll try cruel first.
#  * We don't have to worry about the '100 diameters' thing,
#    assume we can only jump from the 'jump point' which
#    by definition is at a safe distance. Later we can
#    consider adding the option. (Lots of bits in the game
#    that make sense for a party of adventurers, but not
#    so much for an ostensibly commercial vessel.)
#  * Open question: if the drive fails, is this before or
#    after the jump completes? Let's rule that drive failures
#    from maintenance happen before, and misjumps and 
#    failures from fuel happen during/after ('in flight').
#  * We may want to move the 'tow truck' feature up the list
#    after this, since many more chances for a ship to get
#    stuck out at the jump point.
#
#  Nothing mentions costs here, either. (Not even in the 
#  starship combat section.) May want to flesh this out 
#  with some rules from later editions, but again let's
#  start with RAW '77.
#
#  For repairs, I'm thinking three states, which we'll track
#  with an enum for now: REPAIRED, BROKEN, and PATCHED (state
#  inbetween the other two). Normal status is REPAIRED. On
#  drive failure, it goes to BROKEN. An engineer can repair
#  from BROKEN to PATCHED. A starport can repair either fully.
#  A BROKEN ship cannot move at all, either jump or maneuver.
#  A PATCHED ship cannot jump.
#
#  The rules do state that D/E/X starports have no repair
#  facilities (Book 2 p. 5). Harsh. This is game over 
#  conditions.
#
#  I'm going to base the repair rules (slim as they are)
#  on the 'flush tanks' command. Let's assume it also
#  takes a week, and as a bonus will flush the tanks
#  at the same time. Costs TBD. Free for now.
#
#  Another quick ruling: annual maintenance will repair the
#  ship completely if necessary. Seems pretty obvious, though
#  not explictly mentioned in RAW.
#
#  Testing (and looking at the math) shows that unrefined fuel
#  is MUCH more dangerous than skipping maintenance. If you're
#  going to take chances and save a little, choose the latter...
#  Unfortunately, starport configuration and the possibility of
#  wilderness refuelling may leave you little choice.
#
# -------------------------------------------------------------

# -------------------------------------------------------------
# On to misjumps. Checking for them is simple enough, but 
# setting the destination has a couple wrinkles:
#
# * First, we could end up in an empty hex. Per 'let's be cruel,'
#   we'll let that stand for now. But it does mean we won't have
#   a StarSystem object (just None) upon arrival, and will hit
#   an error trying to get properties from it.
#
#   This _is_ a game over condition, at least for now. So we
#   could cut to such a message. Though I haven't yet sketched
#   out what the 'game over' feature should look like...
#
#   Alternatively, we could add a null object to the StarSystem
#   hierarchy, and put that in all 'empty' hexes. It would have
#   minimal properties to be able to handle this accidental
#   jump. (And then presumably the player quits the game. Once
#   we flesh out the full game structure, something slightly 
#   more involved could happen here.)
#
# * Second, per RAW, this destination is chosen from only the
#   six axial hexes surrounding the origin world. That's largely
#   to keep it simple for a pen-and-paper procedure. It would
#   be easy to instead find _all_ hexes at the given distance,
#   and pick one randomly.
#
#   For now, go with axial. Very simple to calculate.
# -------------------------------------------------------------

# -------------------------------------------------------------
# Last feature for Phase Three: naming star systems. This is
# a potential rabbit hole. Will try to keep it simple and 
# scoped. Two approaches occur to me:
#
# * Full on generator, probably using the stuff GDW introduced
#   in the alien book series.
#
# * Randomly pick off a word list. I did this a couple times for
#   previous subsector generators. Grab a dictionary list off
#   the internet, scrub out obviously unusable words (like 1-2
#   letter words for instance). Then just randomly choose.
#   Probably would want to randomly pick a line from the file
#   rather than load the whole thing up. If we have to do the
#   latter, maybe discard after creating word so we don't have
#   memory overhead (though admittedly, don't think it would
#   be all that bad. Another 'perf is moot until it's not' 
#   kinda thing.)
#
# To get it up and running, let's do the latter. It's pretty
# simple. Find a file and cook it. Then add a word generator
# module. That way we can always switch strategies later
# and the rest of the code doesn't have to know a thing.
#
# OK. Got it working. Pretty short list, so there will
# be repeats, but we can always expand it later. Also,
# adding prefixes/suffixes, like "New" or "Station" will
# add even more variety. Good enough for now.
#
# I've accumulated a bit of technical debt through this
# push, so should spend some time cleaning and refactoring
# before we move on. Phase four was already a mix of
# engineering cleanup and game mechanics overhaul. So we'll
# split it up, and tackle the engineering bit first. Easy
# place to start is to get pylint/pydocstyle clean, and 
# maybe some Beck-style tidying.
#
# -------------------------------------------------------------

# -------------------------------------------------------------
# Working through tech debt. Plenty to do. I separated the unit
# tests into their own modules for starters. Then I've been 
# gradually scrubbing one module at a time. Tackling method
# docstrings helped clean up the pylint output so it's a
# useful length. There are a few big methods, especially in
# the core traveller module, that will be the most interesting.
# Once they're broken apart, lots of opportunities to move
# them around, merge, etc.
#
# That core module is a bit of a PITA, though. Because it's 
# almost entirely side effects, I opted to skip unit tests
# for it alone. And the lack has bit me a couple times 
# already. We'll get there, but I look forward to isolating
# the side effect UI stuff and being able to test just about
# everthing else.
#
# So phases within the phase... I'll want to stop cleanup at
# some point and get back to feature work, so we need a cutoff.
#
# First bit I'd like to hit at a minimum is (almost) 100% pylint &
# pydocstyle hygiene. We'll have to decide case by case when 
# there's some tricky bits, but I should be able to
# get 95%+. I also just started fooling with type annotations
# and mypy, so add that to the bar as well. And finally, each and
# every method should have at least one unit test. This is a
# pretty basic level of hygiene.
#
# Later goals, we'll do as much as we can before cleanup fatigue
# sets in. I'd like to:
#
# * Get better test coverage. Make sure all branches are touched,
#   think more about equivalence testing, etc. Also consider
#   the manual test cases - we have a general script, but some
#   more targeted 'break stuff' approaches would also be helpful.
#
# * Lift up all the UI print/input stuff so we can stop skipping
#   tests. This may take us partly or all the way to MVC. We
#   really should be thinking about print & input as UI
#   components, possibly even wrap them in some component
#   classes. Always think about how we might convert this
#   to a full GUI or other graphical approach - what works, 
#   what breaks?
#
# * Scrubbing for Beck/Fowler code smells. There's a bunch, 
#   and I know I suffer from more than a few, so this is
#   a can of worms. Bring hot sauce.
#
# -------------------------------------------------------------

# -------------------------------------------------------------
# Working out a bug where after a misjump the destination does
# not appear in the 'view all systems' list. Looks like an
# oversight in the logic.
#
# StarSystems are only added to the StarMap dictionary in
# get_systems_within_range() (or in the class ctor for 
# pregenerated worlds), and we only call that when adding 
# destinations to a given StarSystem. We have to force
# the call for the starting point. After that, we call again
# after jumping to each new destination. But note that the
# destination itself already exists in the dictionary, or
# we wouldn't be able to select it for jump.
#
# Misjumps violate this rule. The player doesn't select the
# destination - the dice do. So, although we properly 
# populate the misjump target's neigbors after we arrive,
# the system itself is never added.
#
# I put a one-line fix in _misjump_check() to correct. Still
# may want to think through the ordering more carefully. We
# have (so far) three cases when StarSystems are added, and
# we need to ensure that in all three the new object is
# added to the StarMap dictionary. So should we move this
# linkage up? Not sure if that would introduce new problems,
# so we'll leave the simple fix for the time being. When
# we start save/load of maps, may need to revisit.
# -------------------------------------------------------------

# -------------------------------------------------------------
# Should track progress on the current refactoring push. I
# really want to get back to features, but it would be a mistake
# with some of these structural issues. How close are we?
#
# And done! First completely clean linter output. I punted
# on a few of the trickier bits and disabled feedback, but 
# overall the codebase is much cleaner. Let's push the 
# unaddressed TO_DOs to another cleanup pass after a round
# of feature work.
#
# 119/124 unit tests passing (5 skipped)
# 100% pydocstyle passing
# 100% mypy passing
# 100% pylint passing
#
# Added a shell script to run pylint/pydocstyle/mypy and all
# unit tests against all python modules. I've brought the
# errors down enough that the output fits on one screen (though
# admittedly I've had to disable a handful of pylint issues
# that will need cleanup later). Just a few annotation issues
# and we can move on. This is a good baseline to maintain.
# Don't regress below this point, ever.
#
# I'm still unsure of the value of the annotations. They're
# a bit noisy, and I don't think they've prevented any bugs.
# I've had to jump though some strange hoops to make mypy
# happy, but Python ignores all of it, so hrm.
#
# But maybe that's an indicator to keep an eye on. Complicated 
# type annotations are a code smell. So are any directives to 
# ignore linting, for mypy and for pylint.
#
# -------------------------------------------------------------

# -------------------------------------------------------------
# OK. So an observer model can help with the print statements
# scattered around the model classes. Not yet sure how to 
# handle input, though something similar may apply there too.
#
# I was able to build this into Ship, wire up Game to print
# the received messages, and voila! Nice bonus, the previously
# skipped unit tests can now be unskipped.
#
# Just need to apply this everywhere. Also, I added 'priority'
# to the protocol to allow for urgent messages. Right now it's
# just a string that maps to different 'print colored text'
# functions. May want to formalize this later.
#
# That seems to be working OK. All print statements isolated to
# Game and utilities. And I was able to get all the tests 
# working (that only had print side effects). One gotcha - need
# to rewire the observers when the subject changes. We make a
# new CargoDepot after performing a jump. The other two classes
# we're interested in right now (Ship & Financials) persist for
# the whole game.
#
# So time to tackle input. I think a similar model could work.
# Honestly, the little wrapper input functions in utilities are
# almost there. A couple things to change:
#
# * First, we'll have a separate 'observer' link, since the 
#   protocols will be different of course. Let's call it
#   'controls.'
#
# * Second, unlike Views, I don't think it makes sense to have 
#   a list of controllers. Just one. So the pointer will be a
#   single object, not a collection.
#
# OK, easy enough to set up. Got this working in Ship. Basically
# the same pattern as the observer messages. Now just need to
# get it working in Cargo and all done. No skipped tests and
# UI isolated to the Game class.
#
# Later we probably want to split up the Controller and View
# pieces. Game is getting kinda fat.
#
# -------------------------------------------------------------

# -------------------------------------------------------------
# Cleared out a couple easy features, but now for something
# more substantial. I want to get to save/load game, but it
# makes sense to have a menu, so let's start there. We need
# a front end where we can start a new game, or load one. Later
# add other bells and whistles like exporting the map data, etc.
#
# So a simple menu. In basic games (usually real-time), there's
# an FSM governing overall game state, which is either the start 
# menu or in the game itself (and maybe a GAME_OVER). The main 
# game loop calls update() and draw() once per tick/frame, and 
# each of those functions changes behavior based on the game state.
#
# Simple enough. But a couple observations:
#
# * First, the loop in this game is not real-time, but only
#   ticks forward after each player command completes. Don't
#   think that's an issue, but structurally we don't have
#   update()/draw() to hold all the state behavior switching.
#
# * Second, I already have a close analogue to states with
#   'location.' I had originally thought of them as such, but
#   functionally they behave just like an FSM, with simple
#   transitions between each. And frankly I haven't been 
#   happy with the current muddled implementation. So this
#   is an opportunity to clean that up. It should straighten
#   out StarSystem, and probably Command/Commands too.
#
# May also be helpful to represent each of these states as
# an object, like CargoDepot. All the action logic lives in
# them. I had overloaded CargoDepot with most of this due to
# fears of code duplication, but seems worthwhile to go ahead
# with it. If there's duplication, we can handle either via
# stateless utility functions or some sort of parent class 
# (or maybe composition).
#
# Currently, a 'location' has:
#
# * A set of transition commands to other locations, with
#   appropriate constraints based on other game states. Also
#   potential costs for the transition.
#
# * Transition commands (almost) all wrap a method on
#   StarSystem that just changes a flag (a string actually).
#
# * A descriptor string used by the UI.
#
# * A collection of commands it will accept. In addition to
#   transitions, there are unique actions for each location.
#   There are also 'view' commands, which are (mostly) allowed
#   from any location.
#
# Challenges with breaking this up:
#
# * To avoid coupling, I intentionally routed the commands
#   through methods on Game. The methods then split into two
#   parts to segregate the UI pieces from the lower model
#   classes. (Early versions of this used global objects and/or
#   passing around of classes, and the commands directly invoked
#   lower level objects.)
#
# * Those UI pieces: View and Controller. It's already clear
#   the methods in Game are doing too much. They've been partly
#   broken down, but I haven't taken it far enough yet.
#
# CargoDepot (and to a lesser extent Commands) is the only
# class close to this model. So I think some of the work to be
# done is:
#
# * Create new classes, one per state.
#
# * Move logic down from Game into those classes (including
#   CargoDepot).
#
# * Pull location (i.e. state) transitions out of Game and
#   StarSystem and place into appropriate classes. (But does
#   this couple them to one another?)
#
# * Figure out dispatch from and ownership of Command. The
#   Commands class probably gets split up between the new
#   classes.
#
# * Probably also separate out Controller and View pieces
#   from Game, at which point the command methods go away.
#
# Seems like some heavy lifting, especially given how 'untestable'
# the traveller module is. We could get very broken for a long
# time. Is there an easier way?
#
# What if instead we sneak in a little 'menu' state in the
# game loop, and test out how that would work? Use it as a
# prototype for what comes next. Let's give that a spin.
#
# OK. Started with the 'little menu' using an enum to govern
# state in the game loop. Needed to duplicate some of the
# command-handling logic, but everything worked. Also mocked
# up a very basic 'save game' that just dumps the map
# listing to a file. We'll hold off on a real implemetation 
# of save/load for now.
#
# After that was running, I pushed through much of the 
# 'heavy lifting' mentioned above. Heavily refactored
# Game and dropped almost all its methods down to the 
# new Screen class hierarchy. The screen are the states.
# Was able to do away with the state enum, now we just
# switch screens. Also was able to kill the weird Commands
# class. Only a couple pieces left: pulling remaining 
# controller/view stuff out of Game, and lifting
# the location transition code out of StarSystem.
#
# The methods pushed down are still bloated and need lots
# more work, but at least now they're split between several
# classes. Also I have the entire screen hierarchy in one
# module, so they will get split up as this continues. And
# they still all route up through Game to access model state.
# Probably want to clean that up too.
#
# For now this was a good refactoring push. Switching back
# to some more little features for a bit. Save/load is one.
# Coordinate conversion is another.
#
# -------------------------------------------------------------

# -------------------------------------------------------------
# Notes originally kept in src/star_map.py:
#
# in the three-axis system:
#  * the three coordinates sum to zero
#  * the distance from origin is max(|x|, |y|, |z|)

# the origin is of course (0,0,0)
# the six surrounding coordinates are:
# (0, 1, -1), (0, -1, 1)
# (1, 0, -1), (-1, 0, 1)
# (1, -1, 0), (-1, 1, 0)

# the axial rows are straightforward. one
# coordinate is zero, and the other two are
# +x/-x. So:
# (0,x,-x) & (0,-x,x)
# (x,0,-x) & (-x,0,x)
# (x,-x,0) & (-x,x,0)

# A ring of hexes at a given distance from a
# central origin hex contains six axial hexes
# and a variable number of edge hexes. There
# are (range-1)*6 such hexes, so 0 at range 1,
# 6 at range 2, 12 at range 3, etc. So the total
# number of hexes in a ring are equal to:
#   6 + (range-1)*6.

# As noted above, axial hexes are trivial to
# figure out. Just all the valid variations of
# +range, -range, and zero (one of each per coord).

# Edge hexes are trickier. They are grouped into
# six 'pie slices,' each bounded by two different
# axes. If we call the axes red, blue, green, then
# the slices are:
#   +blue, +red     (-green)
#   -red, -green    (+blue)
#   +blue, +green   (-red)
#   -blue, -red     (+green)
#   +red, +green    (-blue)
#   -blue, -green   (+red)
#
# (Each slice also sits entirely to one side of the
#  third 'non-bounding' axis, as noted in parens above.)
#
# The edge coordinates at a given range are the sum of
# the corresponding axial hexes along that span, just
# like with Cartesian coordinates. It's the same sort
# of transform - go over 3 on the x-axis, and up 2 on
# the y-axis, and arrive at (3,2). Instead we would
# go over 3 on the blue-axis, and up 2 on the red-axis,
# and arrive at (3,2,-5). The third coordinate is
# really just a checksum and can be calculated given
# the other two, since sum(a,b,c) = 0. Tricky bit is this
# hex is _five_ away from the origin, so arriving at it
# from just the range value is tricky.

# An alternate strategy:
# * the complete set of coordinates at a given range x
#   (including invalid coordinates) is given by:
#   [(a,b,c) for a in range(-x,x+1)
#            for b in range(-x,x+1)
#            for c in range(-x,x+1)]

# * the length of this list is (2x+1)^3, so
#   27 (3 cubed) at range 1, 125 (5 cubed) at range 2, etc.
#
# * we can then filter out the invalid members with a
#   simple test, and voila! There's the list at range x.
#
#   [a for a in full_list if sum(a)==0]
#   a.remove((0,0,0))                   # probably also want
#                                       # to drop the origin...
#
# Then, if we want to find hexes around some arbitrary
# point, we just translate everything to that new origin
# (by adding the new origin to every coordinate of course).

# Converting to Traveller coordinates from 3-axis
# -----------------------------------------------
# As noted elsewhere, Traveller 77 uses an 8x10 grid of
# hexes, called a 'subsector.' Each hex is assigned a
# coordinate by row and column, as RRCC. So coordinates
# range from 0101 to 0810.
#
# Later game editions expanded this to a 'sector,'
# comprised of sixteen subsectors in a 4x4 grid. Initially
# worlds were still referenced by subsector coordinates,
# with the name of the subsector to distinguish. Later
# they started using coordinates based on the 32x40
# arrangement in the sector, so coordinates could now
# range from 0101 to 3240.
#
# For conversion, there are a few hurdles to cross:
#
# * Column number is easy. It maps directly to one of
#   the 3-axis values. Arbitrary. My hand-drawn version
#   I've been using to figure this out happens to use
#   the second value as the column offset.
# * Row number needs calculation. I have another project
#   where I figured this out; will crib if the derivation
#   doesn't come back to me easily.
# * Then need to address subsectors and sectors. First
#   as entities in their own right. I suppose eventually
#   I'll want to formalize them here, at a minimum for
#   any export functionality (and possibly import too),
#   but maybe make them visible in-game too.
# * But second, the impact on coordinates. Do we convert
#   to 8x10 or 32x40 values? And how do we handle crossing
#   boundaries?
# * Of course there will need to be some base offset. Where
#   is (0,0,0) located on the sector/subsector map?
#
# For the first steps, let's place the origin in the middle
# of a sector, so at 1620. That way we don't have to worry
# about boundaries just yet.
#
# ( 3, 0,-3)   0603  ( 0,-3)
# ( 2, 0,-2)   0604  ( 0,-2)
# ( 1, 0,-1)   0605  ( 0,-1)
# ( 0, 0, 0)   0606  ( 0, 0)
# (-1, 0, 1)   0607  ( 0, 1)
# (-2, 0, 2)   0608  ( 0, 2)
# (-3, 0, 3)   0609  ( 0, 3)
#
# ( 3,-1,-2)   0504  (-1,-2)
# ( 2,-1,-1)   0505  (-1,-1)
# ( 1,-1, 0)   0506  (-1, 0)
# ( 0,-1, 1)   0507  (-1, 1)
# (-1,-1, 2)   0508  (-1, 2)
# (-2,-1, 3)   0509  (-1, 3)
# (-3,-1, 4)   0510  (-1, 4)
#
# ( 3, 1,-4)   0703  ( 1,-3)
# ( 2, 1,-3)   0704  ( 1,-2)
# ( 1, 1,-2)   0705  ( 1,-1)
# ( 0, 1,-1)   0706  ( 1, 0)
# (-1, 1, 0)   0707  ( 1, 1)
# (-2, 1, 1)   0708  ( 1, 2)
# (-3, 1, 2)   0709  ( 1, 3)
#
# Transcribing from a physical map (above), and I think this is
# the formula:
#
# * Column offset = second 3-axis value
# * If column offset < 1, row offset = third 3-axis value
# * If column offset >= 1, row offset = -first 3-axis value
#
# Let's try it out...
# OK, test drove an implementation below, and it works according
# to the sample above... but grabbing some other coordinates off
# the map for additional verification, and we have issues. I have
# sneaking suspicion the location of the coordinate within the
# six 3-axis sectors holds the solution.
#
# Additional test cases seem to corroborate. Taking the six
# 'spine' hexes out from the origin, four are OK, implying +/-
# sectors match my algorithm. But the two sectors parallel
# to the column progression (i.e. left/right) fail. Need a tweak.

# ( 2,-1,-1)   0505 (-1,-1)    ok
# (-1,-1, 2)   0508 (-1, 2)    ok
# ( 1, 1,-2)   0705 ( 1,-1)    ok
# (-2, 1, 1)   0708 ( 1, 2)    ok
# (-1, 2,-1)   0806 ( 2, 0)    not ok, algorithm produces ( 2, 1)
# (-2, 4,-2)   1006 ( 4, 0)    not ok, algorithm produces ( 4, 2)
# (-1, 5,-4)   1105 ( 5,-1)    not ok, algorithm produces ( 5, 1)
# (-4, 5,-1)   1108 ( 5, 2)    not ok, algorithm produces ( 5, 4)
# ( 1,-2, 1)   0406 (-2, 0)    not ok, algorithm produces (-2, 1)
# ( 2,-4, 2)   0206 (-4, 0)    not ok, algorithm produces (-4, 2)
#
# so, looking at the sectors, the signs for the first and third
# coordinate may reveal which is which:
#
# left      (+,,+)   col < 0
# right     (-,,-)   col > 0
# top-left  (+,,-)   col < 0
# top-right (+,,-)   col > 0
# bot-left  (-,,+)   col < 0
# bot-right (-,,+)   col > 0
#
# axial rows have one value at 0, so may belong to two sectors,
# need to validate - but if so, current simple implementation
# should work (does in cases tried thus far...)
#
# referencing my older project, I only converted from traveller
# coords to three-axis (and not the reverse) so I could use
# it internally for distance calculations. The formulae were:
#
# x = column - 1
# y = -x - z
# z = (row - 1) - floor((column - 1)/2)
#
# This was only vetted for a single subsector, so just one
# quadrant of an inverted cartesian grid. And I didn't bother
# translating away from origin, so IIRC it works from 0101.
# Also, look like I used the first coordinate as column, instead
# of second. But it's something to work with...
#
# To match this implementation, need to change x/y/z up, and
# also remove -1 offset.
#
# x = row - floor(column/2)
# y = column
# z = -x - y
#
# Another insight I had last night: there are actually *six*
# axes in the three-axis system. Half of them are obscured
# because they don't align with how we think of axes in
# a normal Cartesian grid.
#
# In the Cartesian setup, axes actually serve two purposes:
#
# * Denote increasing/decreasing values for one of the two
#   coordinate values, x or y.
#
# * Indicate a '0 row' or '0 column' for the other value.
#
# We don't view these as separate because they are at
# right angles to one another and thus align with the
# other axis. The x axis indicates change in x, but also
# a '0 row' for y. And vice versa.
#
# In three-axis, this isn't true. There _is_ a '0 row'
# at right angles to the primary axis (the 'axial rows'
# mentioned above), but it does not align with either of
# the other two primary axes. The 'changing values' axes
# extend from the spines (vertices) of the origin hex. So
# maybe a 'major/minor' or 'primary/secondary' terminology
# will do.
#
# I don't know yet if this helps in sorting out the
# coordinate conversion math. But above I mention 'six
# sectors' and the bounds for those sectors may matter. Are
# they bounded by primary or secondary axes? I've drawn it
# both ways. Not sure which is more useful.
#
# Alright, little scribbling on a map to find good boundary
# values and plugging that into the test case reveals the
# issue: it's based on distance from origin left and right.
# Not a sector-based problem at all. So the little
# 'floor(column/2)' bit above is the trick. Need to adjust
# that instead to 'int(column/2)' so it is symmetric around
# zero, and seems to be right. Going to tweak the test
# cases to be sure, and to demonstrate better - currently
# a bunch of duplicate cases while I was faffing about.

# There was a flaw in the above logic, just discovered while
# attempting to translate coordinates to a Traveller subsector.
# It's a blind spot. The solution above is correct, but only
# represents half the story. All the manual scribbling I did to
# derive the formulae used 0606 on a 12x12 hex grid, as it
# is roughly central.

# Unfortunately, the fact that's an even column number matters.
# If we shift to odd (like the 0101 top-left hex), the results
# break. I worked up more test data and validated expected
# results, then was able to tweak the formula.

# Unfortunately it now needs to know at least this even/odd
# characteristic, albeit not the exact origin coordinate. Not
# sure the way this is called is the best way yet, but at least
# the test results are correct. We're going to assume for the
# purposes of this game that the origin is always 0101 in the
# (0,0) subsector. Can always change later.

# Too some degree this invalidates the idea of relative
# Traveller coordinates, since we always need to consider
# half of the origin. But no matter.
# 
# -------------------------------------------------------------

# -------------------------------------------------------------
# I sorted out coordinate conversion. Extensive notes in the
# star_map module (which should proabably move here). I punted
# on subsectors, though. The converted coordinates are relative
# only. Still need to put them on a map.
#
# I'm thinking a subsector entity that lives in StarMap (which
# probably holds a list of them). Subsectors should be very
# simple, at least for now - just a name and a coordinate. The
# first subsector is at (0,0) and the others are placed relative
# to it.
#
# To convert a 2-coord from relative to absolute, we need to
# calculate its subsector offset, then retrieve (or create)
# the appropriate subsector. This is pretty simple bounds
# checking. We'll also need to know the position of the hex 
# coordinate origin within the origin subsector - simplest to 
# assume this is always (0101), but would be good to move this 
# to any arbitrary location in the subsector.
#
# Still not entirely sure when we'll want to do the relatve-to-
# absolute conversion. Should Hexes know about their parent
# subsector? Or do we just do this when creating map views/lists?
#
# Sorted out the conversion. There was a bug in my initial
# implementation - turns out whether the origin is in an even
# or odd column matters. But I think it's good now - bunch of
# test cases, and confirmed expected results against a hand-drawn
# map. Relative 2-axis is less convincing now, though, since we
# need to know a little bit about the origin. I _am_ assuming
# the origin is 0101 for now, but the function is flexible enough
# it could allow the thing to move around.
#
# As for subsectors, they are very simple - so much so that there
# isn't really justification for a full class. Right now they
# just have a name and a coordinate; and the coordinate is already
# present in the container dictionary in StarMap. Would be
# simpler to just store the name there and dispense with the class.
# Going to hold onto it a bit longer to see if any code or data
# wants to live there. If not, it goes. (I know longer term we
# may want to express StarSystem generation parameters through
# a Subsector, but YAGNI, right?)
#
# Names for subsectors aren't done yet. Given the very short list
# I'm using for StarSystems right now, there would be lots of
# duplication, which I suppose doesn't really matter during testing.
# More than that, though, I think we'll probably want a separate
# function to generate the names, with different suffixes like
# "Marches" or "Deep" or "Reach."
#
# The lookup in StarMap works much like StarSystem: check the 
# dictionary for the supplied coordinate, and if it isn't there,
# create a new one. Seems fine.
#
# Which brings us back to use cases. When do we care? I think we'll
# want subsectors in the star map view/list, and when we export the
# same. Possibly in the world detail view. But they don't have any
# game effect.
#
# The natural place to put this would be __str__ in StarSystem. But
# that class doesn't have any awareness of StarMap, which it needs
# to look up subsectors. A couple options:
#
# * Rework the container in StarMap, so the map contains Subsectors,
#   which contain StarSystems. And probably parent back-references
#   as needed. This gives the Subsector class a reason to exist.
#
# * Remove coordinates from StarSystem, and separate out the string
#   generation, with the StarMap putting together both pieces (coord
#   and world strings). Subsectors can stay just as string names.
#   One small issue: StarSystem also uses coordinate in __eq__ and
#   __hash__. Could probably change this to something based on its
#   UWP instead. Still need to walk through the potential call
#   chain to see how this would work. I do like how de-coupled this
#   is. No reason for StarSystems to know anything about coordinates
#   or maps.
#
# Alright, taking a look at the map list in-game, and visualizing
# how it ought to look after incorporating subsector names. If we
# include them inline for each system, it's going to look very
# repetitive. Would be better to have section headers, and group
# systems under their respective subsector. I _think_ this would
# be easier under the first approach above, but not sure.
#
# I do think that long (medium?) term, the 3-axis stuff becomes
# internal-only, not player-facing. It's easier to work with for
# sure, but not so easy to visualize relationships just looking
# at a list of coordinates. Even after all the time I've spent with
# it, it's much easier to picture layout from Traveller coordinates.
#
# After some more thought, the first approach will make it more
# difficult to find all systems within range. We'd have to check
# neigboring subsectors. Right now it's all one big list. Since
# they're just references, I suppose we could have _both_, but 
# that's more overhead to manage, so...
#
# I'm going to try lifting coordinates out of StarSystem. And maybe
# we flesh the coordinate class out with its conversions. If we have
# _that_ as the key into the systems list, we can easily lift the
# corresponding subsector coordinates when we need them. May need
# to move various string methods around - StarMap probably owns 
# returning a string combining subsector/coordinate stuff with
# the StarSystem details.
#
# (Actually, would be harmless to leave the coordinate in Hex.
# If we just have a StarSystem, will be useful to be able to look
# things up in StarMap, calculate distances, and so on. Just don't
# want/need a backreference to its parent container.)
#
# OK. Coordinates and subsectors seem to be working fine now. Still
# some refactoring cleanup to do, of course.
#
# -------------------------------------------------------------

# -------------------------------------------------------------
# Next feature: save/load game. A few thoughts:
#
# * Need to decide on format. I like having human-readable data
#   files, so probably not pickle. JSON?
# * Consider import of existing data too. Should this be in the
#   same format? What would that look like for the importer?
# * Already noted below that save should not overwrite previous
#   saves.
# * Should we have an auto-save? After each jump perhaps?
# * I also like the Terraria approach where the world and the player
#   are separate and can be mixed/matched. So you could have:
#
#   1) New world & new player
#   2) Loaded world & new player
#   3) New world & loaded player
#   4) Loaded world & loaded player
#
#   "world" includes all the map data. "player" includes the ship,
#   date, crew and financials. (Starting location would either be
#   origin or a saved coordinate in case 4.)
#
# Start with basics of saving the map (and player current location),
# and loading back into it.
#
# Some quick experimentation shows our objects are not simply
# convertible to JSON. Going to need to write some converters.
# But! I also know that a naive JSON dump can be very verbose,
# with tons of quotes and field names. Tying into the import
# concern above, I'd really like something concise to ease
# data entry.
#
# So some sort of import/export method in each class under
# consideration, that takes/returns a string. And then we
# can clump these strings together in JSON or an even simpler
# format and write or read from a file.
#
# Easy conversion for classes that:
#
# a) Are immutable
# b) Have attributes deterministically generated from ctor args
#
# In that case, we can just capture the ctor args in a structured
# string. Any complex args, rinse and repeat until we get down
# to primitives.
#
# The 'not so easy' conversion needs to snap any mutable/random
# state, and expose mutators to allow them to be set on import.
#
# For the map, we have the following entities:
#
# * Subsector(str, tuple(int,int))               # immutable
# * StarMap(dict(Coordinate:Hex))                # systems/subsectors mutable, 
#                                                  subsectors not exposed in ctor args
# * Hex(Coordinate)                              # destinations mutable
# * DeepSpace(Coordinate)                        # destinations mutable (in theory)
# * StarSystem(str, Coordinate, UWP, bool)       # destinations, detail mutable
# * Coordinate(int, int, int)                    # immutable
# * UWP(str, int, int, int, int, int, int, int)  # immutable
#
# StarSystemFactory.create() is already close to an importer, will
# probably get swept up in this effort.
#
# Classes marked 'immutable' above aren't truly - like many things 
# in Python, it's more a convention than enforced. But current 
# design doesn't modify those objects once created (and if it ever
# becomes a problem, I could add machinery to enforce the immutability).
#
# Anyway. UWP and Coordinate look pretty straightforward, so let's 
# start there.
#
# UWP wasn't too bad. Added a bunch of checks to catch invalid input,
# but otherwise easy enough. We _will_ hit issues later when we
# encounter eHex data. Right now UWP just uses strict hexadecimal
# digits. I also had to make the decoder function standalone. Initially
# I tried a classmethod, but mypy is finicky about how to annotate
# that; this is easier.
#
# Coordinate is next. On the surface also should be easy. Maybe
# moreso, since we only accept +/- integers. But the catch is
# whether to write 3-axis or 2-axis data. The former is easier as
# far as save/load goes, since it is the internal data format.
# And for the latter, we will need subsectors too.
#
# However, data entry using 3-axis doesn't seem feasible. We're
# going to need to be able to interpret 2-axis coordinates with
# associated subsector information. Only thing I think we need
# to insist on over and above published material is a simple
# subsector coordinate so we know relative placement.
#
# That means we'll need to be able to convert from 2-axis w/
# subsector back to 3-axis in order to import.
#
# Let's punt on that for now. A simple save/load can get away
# with outputting 3-axis values. OK, this is working. Secondary
# concern is we're allowing invalid 3-axis coordinates to be
# created, so if there's junk in the save data we can't catch
# it here. Our StarMap algorithm relies on this (create all
# possible coordinates then prune invalid ones). What if
# we call invalid_coords from the import function to test?
#
# That works. I wanted to move all the coordinate stuff from
# StarMap over to Coordinate anyway, so this is a step along
# that path. This one is good enough.
#
# So StarSystem ought to be simple from here, right? (Hrm, I 
# spot one small gotcha with export at any rate. For UWP,
# I enforced that export is the same as __str__. I didn't do
# that for Coordinate. Right now we're including both
# the 'real' 3-axis values and the derived 2-axis relative
# coordinate in there. Cross that bridge when we come to it
# I suppose...)
#
# Quick review, and should be OK. There's some legacy in
# Coordinate.__str__ that we don't need anymore. Three places
# display the coordinate right now (all in Menu commands):
# view_world(), view_map() and save_game(). The first two
# use the trav_coord field directly, not the string
# representation. And the third is just printing 
# StarSystem.__str__ at this time, which used to include
# the coordinate string but doesn't anymore. I think we
# can modify the dunder method and get this aligned. Then
# save_game() _can_ output it just fine.
#
# Sorted. No impact from changing __str__, and I added a
# test case to underscore the contract. On to StarSystem.
#
# That's done. Pretty easy once the underlying converters are
# working. Almost everything we need to load a map now. Three
# aspects left:
#
# 1) DeepSpace. We need to fill in known blanks in the map
#    or the algorithm will randomly fill them once we start
#    playing. Converter should be very simple, but the data
#    entry will be very tedious and redundant. Solve that
#    later. For now do the brain-dead simple thing.
#
# 2) How are StarSystem destinations going to be handled? Will
#    the game just fix these up as we move across the map again?
#    They _are_ just derived from a lookup of the map, so if
#    the map data is the same, destinations should be too. Needs
#    investigation.
#
# 3) Subsectors. I think under the current implementation, we'll
#    just rename all of them on demand. Not breaking, but should
#    get fixed after this.
# 
# Working on DeepSpace. Started with a naive solution, but as I
# dig in it's obvious that this should be a sub-case of
# star_system_from(). Assuming we just have a big list of
# Hexes, whichever function (something like 'subsector_from()')
# won't know whether to call a star system factory or a deep
# space factory. So let the factory figure it out.
#
# Basic save/load of a list of StarSystems is working. The file
# is unstructured and does not contain any subsector data, so
# they are being regenerated on load as hinted above. (And I
# _think_ destinations do indeed get fixed up automatically, test
# flight looks good. Want a more thorough white-box review to be
# certain.)
#
# ...and just added dump of subsectors to save_game(). Very easy.
# But problem is the file is still unstructured, so it crashes
# when we try to load it, as it thinks the Subsectors are
# StarSystems. Need to put this into a simple JSON structure,
# and swap into both save & load.
#
# Switching to JSON easy enough. I'm not loading subsectors
# yet, but can save/load without crashing. Progress.
#
# OK, now save & load are working correctly for StarSystems and
# Subsectors. I also moved the save file into a dedicated subdirectory,
# and added some functions/logic to the commands to support
# multiple save files. Save auto-increments and creates the
# 'next' file, no player choice involved. Load allows choice
# from a list. I'm not capping the length, so this could become
# a problem eventually, but good enough for now.
#
# I had another thought about the 'separate map & player' save idea.
# The upcoming Financials ledger will break (or at least hold 
# nonsensical data) if we allow that. It would refer to StarSystems
# from the previous map, not necessarily same as current. So at
# least for now we'll load the entire monolith. Destinations in
# Passenger/Freight are similarly a problem.
#
# Probably time to get some more game state into the save file. 
# We have Calendar, Ship, location, financials, as well as wiring
# up destinations & observers/controllers if anything shifts
# underneath. (The current implementation has the entire game
# state created behind the scenes before we even enter the Menu,
# then we swap out if loading.)
#
# Calendar next. It doesn't accept a date in the ctor, so simple
# approach would be to allow the pre-existing one to stand, and
# just set its date. But I think that's going to trigger observers.
# So what if we modify the ctor with an optional start date
# parameter? We'd need to re-attach observers with that approach.
# A third cheater tack would be a new method that sets the date
# without firing observers. Need to read through to assess.
#
# The current date is also fed to Financials & CargoDepot, so 
# need to account for that piece too.
#
# OK, observers on Calendar only fire if we touch the day/year via
# properties, but not if we swap the date entirely. Wouldn't even
# need a method. That's the least code to pull this off... Let's
# wrap it in a 'from_string' function like the other model classes
# to make the usage clear, not randomly poking fingers into things.
# (Though breaking convention, we won't create a new object, but
# modify the existing one... We _will_ have another to create
# an ImperialDate from a string though.)
#
# I think longer term we'll pull the model classes out of Game
# into another class, then we can adjust the awkward sequencing.
#
# Basic 'from_string' is done for ImperialDate & Calendar - 
# wiring up through save/load should be trivial. I _do_ think 
# there's some potential weirdness here. For instance, what if
# we load a date a year from now, won't that put it immediately
# into red maintenance state? Need to work through some scenarios
# and ad hoc testing to find/fix the issues. The note above about
# Financials/CargoDepot might be the right focus.
#
# (Also, consider that once we load Financials, it will have a
# valid maintenance date set. The issue just described is only
# true in a torn state, when we're just saving parts of the game.
# So it ought to work out, right?)
#
# On to ship. Most of its attributes are hard-coded in the ctor.
# We mutate the name, fuel, fuel quality, jump counter, repair 
# status, life support, cargo and passengers. We also have
# observers/controls to consider. Later features (custom/alternate
# ship, custom crew, ship modification) will expand this list, but
# for now we assume the hardcoded capabilities.
#
# The attributes are mostly primitives, so simple to encode:
#
# name - str
# fuel - int
# fuel_quality - int enum
# jump_counter - int
# repair_status - int enum
# life_support - int
#
# Cargo and passengers are lists of Cargo/Freight/Baggage and
# Passengers respectively. So we should start with encode/decode
# of those classes.
#
# Just like the Calendar, we'll modify the existing Ship on load,
# allowing the existing Observer/Controller hookups to remain in
# place.
#
# Starting on Passenger, and there's a challenge - this will
# apply to Freight as well. We pass in a StarSystem destination
# to the ctor, and this coupling is going to be tricky to
# manage. From the string we're just getting the system name.
# Even if we search the systems list by name (haven't built
# that functionality yet), no guarantee we'd get the same one,
# since equality/identity for StarSystem includes coordinates.
#
# Coordinates are by definition unique, and can exist free of
# the context of a given map. So maybe we should shift over to
# that approach. Will need to refactor how destinations are
# handled.
#
# Another observation: I don't think we actually use 
# Passenger.__str__ anywhere in the app (need to confirm). So
# there's freedom to alter it as necessary for data import/export.
# Initially I think the passenger manifest was just going to
# list them all out, like we do with cargo, but listing counts
# turned out to be cleaner.
#
# But that also means we only need to store a single destination
# in JSON, not one with each Passenger. The rule for Passengers
# (and Freight) is they all must have the same destination, so the 
# JSON blob could/should look more like the passenger manifest. 
#
# Going to pivot over to Cargo while I mull this over. Argh. It
# has the same problem - source_world. Other than that, though,
# if we assume all Cargo must have come from the cargo table,
# many of the details can be looked up there. We just need to
# store the name, quantity, and source_world. Remainder is looked
# up by name in the cargo table (also don't have that functionality
# just yet).
#
# Thinking about it some more, we probably don't need to totally
# overhaul how destinations work. Just a couple pieces:
#
# 1) Save the coordinate in the string save output. We already
#    have a reference to the full StarSystem object, so easy enough.
#
# 2) Pass in the systems list to any of the 'from_string' functions
#    that need it. Obviously they will need to be called at the 
#    end of load_game().
#
# Hrm. So yesterday I worked up passenger_from() per those guidelines,
# and it works fine. Had to do a bit of refactoring, especially
# in the test module, but all good. However, I completely forgot
# about the more streamlined approach. We shouldn't record a list
# of passengers in the save file. It's sufficient to have just four
# pieces of data: a destination, and counts for each passage class.
#
# One wrinkle, though: Passenger has a few 'hidden' attributes
# that were added to support the low lottery: endurance, guess
# and survived. The latter is only fiddled with upon landing
# and disembarking, so almost certainly always True (don't think
# we could possibly save the game in the middle of that - verify!).
#
# But the other two... check their lifespan. If it matters, we
# should indeed have a list of Passengers, and capture those
# attributes. Otherwise we can go with the simpler approach. 
# (Looking ahead, I _do_ eventually want to give every passenger
# some color, like a name, so...)
#
# Guess is set on liftoff, and checked on landing. So it is valid
# during flight - and since it is set to None in the ctor, if
# we don't set this value we'll crash when we land trying to
# access fields on None. So we either need to rerun guess_survivors()
# during load_game(), or save the value in save_game(). It's
# an invisible random number, so probably no harm in just
# re-creating it.
#
# Endurance is set in the ctor and only checked once during
# the low lottery. Same deal here, it's an invisible random
# value. Seems like allowing the loaded object ctor regenerate
# is perfectly fine.
#
# OK, going to take the easy way out, change later if we need
# to. Since passenger_from() is already written, let's stuff
# that list into the save file. Then we'll call guess_survivors()
# on all the low passengers after loading. We could easily change
# to the streamlined version this way, if there's value.
#
# Another deviation in this one: Passenger.__str__ didn't quite
# match what I needed (uses StarSystem.name instead of 
# StarSystem.coordinate). So I'm cooking up Passenger.encode()
# to handle the responsibility. Longer term will want to think
# about standardizing on __str__ everywhere, or adding an
# encode() (which admittedly could be just a thin wrapper over
# __str__). The latter provides a clear interface FWIW. We'll
# leave it slightly messy for now and see which way things want
# to move.
#
# All that is now working. (Observation, we only need to run
# guess_survivors() if the ship is in space - will be rerun on
# liftoff, so harmless. Fiddle with it later.)
#
# On to the cargo hold. Just like StarSystems, we don't want
# to handle this at the individual class level. The container
# type is List[Freight | Cargo] (and the former encompasses
# both Freight and Baggage), so we want a composite function that
# reads a single list and builds the appropriate type of 
# entity as needed.
#
# Freight needs tonnage, source world, and destination world
# Baggage needs just source_world ad destination (tonnage == 1)
# Cargo needs name, quantity, and source_world as noted above.
# The other fields can be looked up in the cargo table (consider
# whether we should store a key to aid lookup, or is name enough?).
#
# We'll start with Freight & Baggage, since they are very similar
# to Passengers and should be quick. And although the save/load
# methods will want some sort of composite to interact with,
# it will be cleaner (and easier to test) if we have individual
# converters.
#
# The composite needs to know which variant to call. In the
# StarSystem function we handle by tokens length. That's a bit
# fragile, but still might be best approach here too. The lower-level
# functions need to validate as well, obviously.
#
# Freight is length 3, Baggage length 2, and Cargo length 3. Seems
# like we need to tag each line to help out - length is ambiguous. So
# let's prefix with the class name. This is only needed in the 
# composite. The sub-function only need the trailing data. But that
# also means it doesn't need to parse a string. Assume it has been
# tokenized in the composite, and we can get the individual pieces
# (albeit maybe still strings).
#
# Alright, that took a while, but it was pretty mechanical once
# the pattern was established. The contents of the cargo hold is
# now written to and read from the save file. Wrapping up Ship
# should be easy now. Then all that's left is location and 
# Financials IIRC.
#
# And Ship is done. Easy, as expected. Only small wrinkle is 
# needing to hook up the observers afterward. And some thoughts
# about the future of this area. First, we'll need to save some
# additional data when we add more ship types. And second, 
# the fields in the class are of two types: volatile, reflecting
# current game state (and saved in the file), and static, which
# come from the Ship type. We should separate the latter out,
# possibly in a 'ship model' class. That would make it easy
# to load different ship types down the road.
#
# Financials is next. That class has a balance, current date,
# references to ship & location, loan & berth due dates,
# observers, and a ledger.
#
# The various references should just be hooked up after
# creating the new object. The others just get stored and 
# loaded, and there are some data integrity contracts to
# enforce w.r.t. dates. Also ledger could potentially get
# very large. For now we'll just let that go, but it might
# have to be dealt with later.
#
# That _does_ mean that this can't be just a simple string. Just
# like the Ship, there's the basic entity data, and a separate
# container, in this case the ledger. So financials_from()
# takes two pieces minimum. Maybe we should separate the ledger,
# build the Financials, then attach the ledger blob to it.
#
# (Something to come back to later: the import/export model has
# evolved as I've worked through the classes, from very simple
# string in/out to more elaborate schemes. Would be good to
# put them all together and look for symmetries, smooth out
# rough bits, or rework the earlier parts with later learnings.)
#
# OK. Save/load is complete. Just finished wiring up Financials
# and location. Initial tests look good. Need to play around
# a bit more to be sure. And there's plenty of duplication,
# fat methods and other smells that will need attention after
# this.
# 
# -------------------------------------------------------------


# -------------------------------------------------------------
# Some more minor feature work: dumping out the map listing and
# financial ledger. There's some oddities here to smooth out,
# like the lifespan of Subsector - currently they are only
# created when generating pretty_coordinates() for a StarSystem,
# which we only do when viewing a world or the map. So if you
# dump the list prior to that, you'll crash trying to look
# up non-existent subsectors. As a quick hack, I adjusted
# dump_map() to call pretty_coordinates(), so good for now,
# but probably ought to re-work the sequencing here.
#
# I think dump_map() in particular is a short step away from a
# couple other features. Toying with them now:
#
# * Importing published data. Would need to reverse the Traveller
#   coordinate into the internal 3-axis format. And a bit of
#   parsing goo. But otherwise, pretty straightforward, in all
#   likelihood.
#
# * Bigger lift: exporting a bitmap of the map. Mostly have all
#   the data needed for this, but I'll need to play with graphics
#   capabilities. I've added the pillow module and am fiddling
#   around. My older Jave project also worked out all the math
#   for drawing a hex grid, and I recently did a Python project
#   with pygame to do the same.
#
# I'm also accumulating a bunch of technical debt here. I 
# reorganized the files a bit. Need to spend more time on
# cleanup. This feature push ought to end soon and we'll
# start shuffling code around.
#
# But first, let's take a look at Game ctor. I'd like to get
# that hard-coded data out of there, and large portions
# of it are re-run during new_game() and load_game(). Should
# also verify all the bits have been wired up properly.
#
# We might want a 'new game' function or method to pull all
# this together. One and only one proper way to set up the 
# game state.
#
# Game().run()
#   set self.screen to Menu                           OK
#   create Calendar                                   .
#   create Ship                                       ...
#   create & populate StarMap                         ..
#   create & populate Subsectors                      ..
#   set Game location                                 ..
#   create location destinations                      ...
#   create Financials (needs date, ship, location)    ..
#   create CargoDepot (needs date, location)          .
#   attach observer/controls to Ship                  ...
#   attach observer/controls to CargoDepot            .
#   attach observer to Financials                     ..
#   attach observers to Calendar                      .
#
# Menu.new_game()
#   get player input for ship model                   OK
#   create Ship                                       ...
#   attach observer/controls to Ship                  ...
#   name Ship                                         .
#   create location destinations                      ...
#
# Menu.load_game()
#   get player input for save file                    OK
#   create & populate StarMap                         ..
#   create & populate Subsectors                      ..
#   modify Calendar                                   .
#   create Ship                                       ...
#   attach observer/controls to Ship                  ...
#   add Passengers to Ship                            .
#   add Cargo/Freight to Ship                         .
#   create Financials (needs date, ship, location)    ..
#   set Financials Ship reference                     .
#   attach observer to Financials                     ..
#   add Ledger entries to Financials                  .
#   set Game location                                 ..
#   create location destinations                      ...
#   set Financials location reference                 .
#   set CargoDepot location reference                 .
#   return appropriate Screen                         OK
#
# I think we should move most of the Game ctor contents into 
# new_game(), then refactor any duplication between it and 
# load_game(). And honestly, new_game() is essentially
# just load_game() from a static file, with some 
# added player input/customization.
#
# This will also lead into separation of all the model
# classes from Game. I think we'll end up with a Model
# class, and a factory function to build it, and both
# new_game() and load_game() will call into that.
#
# Initial cleanup of this area is done. Duplication between
# the two methods has been factored out into helper methods, and
# all dummy data and instantiation in Game ctor has been
# eliminated.
#
# -------------------------------------------------------------

# -------------------------------------------------------------
# Next push: importing published data. I want to keep the data
# entry as simple as possible, ideally matching the published
# sources so this could be grabbed from a pdf or OCR.
#
# But we _do_ need at least two pieces of data to construct the
# map: subsectors (and their relative placement) and star systems.
# So the input file needs to differentiate, so we will need some
# minimal structure. An ini file sort of format ought to meet
# the need.
#
# I have this part working, and a sample file in place to test
# it out.
#
# The next step is converting from Traveller coordinates to
# our internal 3-axis format. Once that is done, the rest ought
# to follow the same procedure as new_game() & load_game() (and
# provide yet another refactoring opportunity).
#
# coordinate.convert_3_axis() & coordinate.absolute() are the 
# existing reverse of what we need, especially the latter.
#
# absolute() returns a tuple of coordinate & subsector coordinate
# given a 3-axis coordinate (and this is what we should be getting
# in the imported data).
#
# Examples:
# (1, 1), ( 0,  0) => ( 0,  0,  0)
# (2, 1), ( 0,  0) => (-1,  1,  0)
# (8, 8), (-1, -1) => ( 3, -1, -2)
# (8, 9), (-1, -1) => ( 2, -1, -1)
# (8, 1), (-1,  0) => ( 0, -1,  1)
# (1,10), ( 0, -1) => ( 1,  0, -1)
#
# I have an implementation, testing it out to make sure it is
# solid. But another challenge occurred to me: EmptySpace. If we
# don't fill in all the blanks, the game engine will potentially
# generate new StarSystems. So we need to address this.
#
# Three solutions in mind:
#
# * Explicitly enter blanks in the import data. This would be the
#   simplest to implement, but pushes the burden to data entry, going
#   against the goals above. Not a fan.
#
# * Have a simplified section in the import data that just lists blank
#   coordinates. This is a less burdensome form of the previous. Still
#   not great.
#
# * Assume subsector data is complete, and fill in any not presented
#   with EmptySpace, automatically. The importer needs to be aware, 
#   however. They need to import entire subsectors. Going to give
#   this a try. If it's unpleasant to manage, we can pivot to one
#   of the other solutions.
#
# Oh, something else to verify and document: I think I implemented
# computer graphics style coordinates for the subsectors. In
# Traveller terms, Coreward & Spinward are negative, Rimward &
# Trailing are positive. This is probably surprising for 
# anyone who doesn't work with screen coordinates regularly, and
# should be documented.
#
# Basic import and creation of StarSystems and Subsectors is
# working (though I haven't completed setting up the game, so
# can't yet verify through play - looks good though). Now to 
# figure out how to add EmptySpace.
#
# Neither Subsector nor StarSystem has a link to the other right
# now. The former has no real functionality, either, and I've
# contemplated killing it off. There's also some questions about
# the lifespan of the class, because other than when loading or
# importing a game, we only create subsectors when we're viewing
# world or map data. They don't really do much of anything.
#
# But! In this case it sure would be handy to have something
# we could query to tell us if every hex in the subsector has
# been evaluated/assigned or not. And the obvious choice would
# be methods on Subsector itself.
#
# I'm hesitating, though, because that would probably involve
# Subsector holding a list of references to Hexes. And that
# muddles our internal map model. I've intentionally built
# around a flat map using 3-axis coordinates only. The other
# map artifacts (2-axis coords, subsectors) are a view on
# top of that.
#
# But if we _don't_ maintain lists of which hexes are occupied
# per subsector, we either need to:
#
# * Repeatedly query the list of systems to see if a coordinate
#   of interest is in it - which involves walking the entire
#   list every time. Can't even be memoized, because the list
#   changes as new systems are created.
#
# * Build temporary lists inside whichever function needs to
#   know.
#
# At the scale of this app, may not even matter. A full Sector
# (sixteen Subsectors) is 32 x 40 hexes, or 1,280. Even if 
# every one is present in the systems list, that's really not
# that big. So performance is not a primary driver of the
# design here. Still don't like the ugliness of walking the
# list over and over, though.
#
# Let's say we have a function called fill_with_empty_space().
# It takes a subsector, then walks all 80 of its hexes to see
# whether they should be filled with EmptySpace, or a StarSystem
# already exists there. It would walk the systems list looking
# for 0101, then 0102, etc. all the way up to 0810. If it
# finds an entry, it skips to the next. If it does not, it 
# creates an EmptySpace, adds it to systems, and moves on.
#
# Repeat the above for every subsector in the import list. Is
# it really that bad? On average, we're going to have 40 entries
# in the list for each subsector - even a full sector would
# only be 640 entries (though admittedly the list grows as
# we move through, until at the end all 1,280 are present).
#
# It _does_ have the advantage of being very simple to 
# implement. The alternative would be adding references to
# Subsector (I imagine a dictionary keyed by coordinates), and
# we would need to plumb that through the rest of the game.
#
# We could optimize the 'growing list' problem by accumulating
# EmptySpace items, and only adding them to the systems list
# after we're done. But still, I image that would be in units
# of a Subsector at a time, so later Subsectors still suffer.
#
# Other caching? The general idea of memoizing is what we
# need to keep from looking at the same items over and over.
#
# So instead, what if we walk the list once, and capture all 
# Systems that are present in the Subsector we're interested 
# in. Then subtract that coordinate list from the full 80 and 
# we have the EmptySpace locations. Open question whether 
# Subsector keeps these lists for later, or if we throw away 
# once the function exits.
#
# We'll try it with the temp var approach - can always move
# this data into the class later, and work out how it meshes
# with the rest of the game at that time. So...
#
# for sub in subsectors:
#   occupied: List[Tuple[int,int]] = is_in_subsector(sub, systems)
#   for coord in 0101 to 0810:
#     if in occupied:
#       next
#     else:
#       systems.append(new EmptySpace(coord))
#
# Needed to do some conversion so we can properly compare, and
# have the right data on hand to create the EmptySpace, but this
# is now working. Adding the rest was very simple. Heavy duplication
# with new_game(), so we'll need some refactoring after this.
#
# Also, an alternate approach occurred to me. What if instead of
# launching a new game on import, we create a json file, name it
# so that it is preserved, and load into it?
#
# Think through the various ways to start the game between new, load
# and import. They are all very similar, and should share functions
# as much as possible.
#
# I've added two subsectors from the Spinward Marches to test
# things out. Overall working as desired. There's a bug needs
# fixing - spaces in world names break the parser. And plenty
# of refactoring cleanup needed.
#
# Another observation: I'm using the original Supplement 3 from
# 1979, and I'm spotting errors in the content. For example, they
# marked Efate (Regina 0105) as non-industrial, but it is definitely
# industrial (atmosphere 4, population 9). Bit outside the scope
# of this game, but would be interesting to trace edits and see
# if they fixed this in later publications. In any event, I am
# calculating all trade classifications from UWP, not from the
# import file, so mine ought to be correct. Discrepancies could
# indicate bugs, or errors in the source publication, so I want 
# to review.
#
# I'm also not supporting bases, travel zones, xboat routes,
# allegiance or supplemental remarks (like way stations, capitals,
# etc.). Yet.
#
# -------------------------------------------------------------

# -------------------------------------------------------------
# On to map drawing. I wrote a standalone module using Pillow
# that draws a subsector map. Right now it's completely dummy
# data, just working on the visuals. From here we'll need:
#
# * choosing subsector to draw
# * feeding in map data
# * integrating into game code (or should this stay standalone?)
# * drawing hexes according to data
# * file output handling
# * consider configurable color scheme - or at least support
#   light & dark so we have a printable version. Current scheme
#   is dark.
#
# A few other things:
#
# * I established the current layout by trial and error. Working
#   out the math, the numbers I arrived at are close, but with
#   integer rounding and so on, not sure how well this scales.
#   May well break (visually) if we alter bitmap dimensions.
#
# * NixOS issue, not really a problem with this project. Mypy
#   can't locate a library for Pillow, and throws an error.
#   Python/mypy's suggestions (to use pip) don't apply here.
#   Reading up on nix docs, and need to figure it out. It's not
#   a simple one-step solution, or at least not until I understand
#   nix a bit better. Going to live with the error for now, but
#   this is going to be very annoying.
#
# * I hard-coded a font path from my system into the drawing
#   script. Obviously this isn't portable. I haven't yet found 
#   any programmatic way to list available fonts on nix or within 
#   Pillow. Unless I do, should either use the default font
#   (which was pretty ugly in my limited testing), or include
#   a font in the application data. Obviously need to find
#   something open source and free to copy around.
#
# Alright, working on the feature. I think integration into
# the game should be first - otherwise we'd have to create
# a bunch of code to parse save or import files to get the
# star system data, and that would duplicate already-tested
# code. First step is to create a menu action that will
# invoke this module.
#
# That's working fine. Piping the data into the drawing module
# uncovers some duplication and missing utility. Should take
# a closer look at how the system list is utilized across the
# entire app, and streamline usage.
#
# Also, it occurs to me that map hexes have three states, not
# just two: StarSystem, EmptySpace, and unmapped. There's some
# thoughts below about "Fog of War" that could use the last one.
# For now, in drawing I am going to handle EmptySpace and
# unmapped identically, but would be easy to draw them differently
# down the road.
#
# Basic features are working, and map resembles standard set
# in later Traveller '81 publications, minus the missing
# features like travel zones.
#
# Still not entirely happy with the randomized icon I'm 
# generating for asteroid belts. Will keep fiddling with it.
# But the core map drawing functionality is done.
# 
# Preventing file overwrite, and customizing colors (or at 
# least providing a print-friendly version) is what's left.
#
# And those are done. That about wraps up major features for
# the basic game. Lots of small tweaks to be done; I'm sure
# playtesting will uncover a bunch of suggestions. Really
# should push down the technical debt first though.
#
# -------------------------------------------------------------

# -------------------------------------------------------------
# Just watched an interesting YT video from 'runevision':
# "Layer-Based Procedural Generation for Infinite Worlds."
# He doesn't get into any implementation details, just the
# overall strategy - but it perfectly captures the challenge
# with the route mechanic in Traveller '77.
#
# This mechanic was removed from later editions, and replaced
# with an ad hoc 'x-boat route' marking on the maps. In '77
# there was a procedure for determining whether a route
# exists between two worlds. The issue is worlds at the 
# boundary. They could have routes connecting to worlds
# outside the generated map. So how to handle?
#
# The strategy in the video is to define 'levels' or 
# 'layers' of generation, from zero on up. Given a grid of cells
# (which could be subsectors in our Traveller example),
# you can only generate a grid at level N if all eight of its
# neighbors are at level N-1
#
# His levels are:
#
# 0) Presence/rough position of locations within each cell
#    (he randomly generates three points per cell)
# 1) Precise position - not too close to any others,
#    including in neighboring cells
# 2) Radius - cannot overlap with any other points
# 3) Connections - starts with Delanay Triangulation,
#    but reduces so it's not overly connected. Also,
#    every point must be reachable.
# 4) Details
#
# For the Traveller '77 route procedure, the inputs are
# world presence, starport (on both sides) and distance.
# So the levels would be:
#
# 0) Presence (position is by hex, and already precise)
#             (distance is also encompassed here)
# 1) Starport
# 2) Routes
# 3) Full UWP and world details
#
# The procedure is limited to worlds within a 4-parsec distance,
# so rather than full subsectors, this could be managed at the 
# hex level. So to generate the details for one world, you need:
#
# 1) All routes connecting to it from 4 parsecs out
# 2) All starports up to an additional 4 parsecs out
# 3) All world locations up to an additional 4 parsecs out
#
# Maybe we could have a thinner shell on the outside. We need
# to know at least the endpoints within 4 parsecs of all routes
# to the world being generated, and any other worlds within that 
# sphere (up to level 1). But we don't necessarily need to know
# anything outside those boundaries until we move close to it.
# (I think we'd probably want to name them at this time, too...)
#
# This is sort of how Traveller worked in the first place. You
# fill in a map, then later go back and roll up all the UWPs.
# For this game, we're not really saving much performance or
# memory-wise - StarSystems are not terribly burdensome to
# generate or store at this scale. But the two-stage process
# does let us solve the route problem without a sort of 
# runaway generation.
#
# And it also touches on the lifespan concerns I've had about
# Subsectors in particular - but probably should involve
# StarSystems too. If we pursue this, we ought to lay out
# a sequence diagram or the equivalent to understand it
# better.
# 
# -------------------------------------------------------------

# -------------------------------------------------------------
# Starting on a big refactor cleanup and overhaul. First 
# seemingly easy task - breaking up these big modules. I'm
# going to go all the way to Java-style, and have one class
# per module (or closely related functions). Some moderation - 
# the very tiny classes like the Crew positions can stay
# together for now (and I'm contemplating flattening that
# hierarchy anyway).
#
# Mostly that has gone smoothly. Pylint even started showing
# some duplicate code messages once things were split and I
# was able to extract some methods. A few more of those left
# in the test modules.
#
# But the dilemma now is the Screen hierarchy. That module
# (Menu) is the biggest mess in the project - very large, with
# multiple large classes inside.
#
# I pulled them all apart, and now have circular dependencies
# biting me. The problem is each of the Play subclasses
# have state transition methods that return a different subclass.
# And the transitions are bidirectional, so the classes each
# import the other. This worked fine when everything was in
# one module, but now it is broken. Inserting a manager type
# class in the middle didn't work.
#
# I'm now looking at pulling the instantiation up to either
# the superclass or the context. What if we return a string
# and let the 'parent' handle it? Menu._load_screen() works
# like this, might extract and use in both places.
#
# OK. Took quite a bit of effort - many files touched, and
# was in a broken state for a while - but this is done. All
# the screen classes are in separate modules. Nice side effects:
# I was able to kill the ScreenT typevar, and a ton of
# typing ignore directives stemming from it.
#
# For now, the state change lives in Game. And since the
# screens already have a back-reference to parent, they just
# call the method with a string argument and it's done.
#
# Unit tests all passing, pydocstyle unaffected. Pylint still
# has some duplicate code warnings coming from the test modules
# that I'll probably deal with next. And mypy still has the
# Pillow library error which needs sorting. Playtesting
# also looks good.
#
# -------------------------------------------------------------

# -------------------------------------------------------------
# Reviewing the unit tests for mock opportunities, and I had
# some thoughts.
#
# First, you can tell a lot about the class under test by the
# imports in the test module.
#
# The very simplest classes only need themselves imported (plus
# whatever goo the unittest framework itself needs). These are
# all datatypes, and possible candidates for replacement by
# Python's data class mechanism.
#
# The more complicated classes need one or more others imported
# alongside. Ideally, any such should be either simple datatypes,
# or a mock.
#
# The ideal test import for me would be something like:
#
#   import unittest
#   import BunchOfMocks
#   import SomDataTypes
#   import ClassUnderTest
#
# So anywhere we see non-datatype classes being imported into
# a test module (that is not targeting them), we should consider
# replacing with a mock.
#
# Not a hard and fast rule, but seems like a reasonable guideline.
#
# This may also provide hints for moving functions around to
# their proper home.
#
# -------------------------------------------------------------

# -------------------------------------------------------------
# Model class has been added, and has taken over all the object
# references previously held by Game. That latter class is 
# becoming quite simple. Potential to move the controller
# methods out of it, but otherwise it's about where it should 
# be.
#
# Model as it stands right now doesn't do much. It just 
# aggregates references to the various model classes, and the
# Screen classes reach in to do whatever they need to.
#
# They probably shouldn't have that kind of knowledge of the
# interior of the model. Instead, we should expose services
# on the Model class itself to expose anything needed.
#
# A quick grep shows 300 references to "self.model" (about 20
# of those are in Ship, and actually refer to ShipModel).
#
# Analyzing these references is a good place to start. Also, as
# noted above, there ought to be some kind of factory to build
# the Model, that would absorb code from load_game and 
# import_game.
#
# Hopefully these can move in clumps and get wrapped up
# inside larger methods, like "jump_procedure()" and so on. I
# don't want to have dozens of public methods on Model. But
# the goal is to break the import link between the Screen classes
# and all the model classes - ideally they just know about
# the Model parent class.
#
#  self.model.date                                             1+ src/menu.py
#  self.model.date.__str__()                                   2  src/play.py
#  self.model.date.add_observer()                              3  src/menu.py
#  6  self.model.date.current_date                                1  src/menu.py
#  self.model.date.current_date                                2  src/starport.py
#  self.model.date.current_date                                3  src/jump.py
#  self.model.date.plus_week()                                 1  src/jump.py
#  self.model.date.plus_week()                                 1  src/play.py
#  self.model.date.plus_week()                                 2  src/starport.py
#
#  self.model.depot                                            1+ src/jump.py
#  self.model.depot                                            1+ src/menu.py
#  self.model.depot.add_observer()                             1  src/jump.py
#  self.model.depot.add_observer()                             1  src/menu.py
#  self.model.depot.broker_fee()                               1  src/trade.py
#  self.model.depot.cargo                                      4  src/trade.py
#  self.model.depot.confirm_transaction()                      2  src/trade.py
#  self.model.depot.controls                                   1  src/jump.py
#  self.model.depot.controls                                   1  src/menu.py
#  self.model.depot.determine_price()                          2  src/trade.py
#  self.model.depot.freight.remove()                           1  src/trade.py
#  self.model.depot.get_available_freight()                    1  src/trade.py
#  self.model.depot.get_available_passengers()                 1  src/terminal.py
#  self.model.depot.get_broker()                               1  src/trade.py
#  self.model.depot.get_cargo_lot()                            2  src/trade.py
#  self.model.depot.get_cargo_quantity()                       2  src/trade.py
#  self.model.depot.insufficient_funds()                       1  src/trade.py
#  self.model.depot.insufficient_hold_space()                  1  src/trade.py
#  self.model.depot.invalid_cargo_origin()                     1  src/trade.py
#  self.model.depot.passengers                                 2  src/terminal.py
#  self.model.depot.remove_cargo()                             2  src/trade.py
#
#  self.model.financials                                       1+ src/menu.py
#  self.model.financials.add_observer()                        1  src/menu.py
#  self.model.financials.balance                               1  src/play.py
#  self.model.financials.balance                               1  src/trade.py
#  self.model.financials.balance                               2  src/starport.py
#  self.model.financials.berthing_fee                          1  src/orbit.py
#  self.model.financials.credit()                              2  src/orbit.py
#  self.model.financials.credit()                              2  src/trade.py
#  self.model.financials.debit()                               2  src/trade.py
#  self.model.financials.debit()                               3  src/starport.py
#  self.model.financials.encode()                              1  src/play.py
#  self.model.financials.last_maintenance                      1  src/starport.py
#  self.model.financials.ledger                                1  src/menu.py
#  self.model.financials.ledger                                3  src/play.py
#  self.model.financials.location                              1  src/jump.py
#  self.model.financials.location                              1  src/menu.py
#  self.model.financials.maintenance_status()                  1  src/starport.py
#  self.model.financials.maintenance_status()                  2  src/jump.py
#  self.model.financials.ship                                  1  src/menu.py
#
#  7  self.model.location                                         1  src/terminal.py
#  self.model.location                                         1+ src/menu.py
#  self.model.location                                         2+ src/jump.py
#  self.model.location                                         3+ src/trade.py
#  self.model.location.__str__()                               1  src/play.py
#  self.model.location.coordinate                              1  src/play.py
#  self.model.location.coordinate                              2  src/jump.py
#  self.model.location.description()                           1  src/play.py
#  self.model.location.destinations                            1  src/menu.py
#  self.model.location.destinations                            2  src/jump.py
#  self.model.location.destinations.copy()                     1  src/terminal.py
#  self.model.location.destinations.copy()                     1  src/trade.py
#  self.model.location.gas_giant                               1  src/jump.py
#  self.model.location.on_surface()                            1  src/orbit.py
#
#  self.model.ship                                             3+ src/menu.py
#  self.model.ship.__str__()                                   1+ src/play.py
#  self.model.ship.add_observer()                              3  src/menu.py
#  self.model.ship.cargo_hold()                                1  src/play.py
#  self.model.ship.check_failure_post_jump()                   1  src/jump.py
#  self.model.ship.check_failure_pre_jump()                    1  src/jump.py
#  self.model.ship.controls                                    3  src/menu.py
#  self.model.ship.crew                                        1  src/play.py
#  8  self.model.ship.current_fuel                                1  src/orbit.py
#  self.model.ship.current_fuel                                3  src/play.py
#  self.model.ship.current_fuel                                4  src/jump.py
#  8  self.model.ship.destination                                 1  src/orbit.py
#  self.model.ship.destination                                 2  src/trade.py
#  self.model.ship.destination                                 5  src/play.py
#  self.model.ship.destination.name                            1  src/starport.py
#  self.model.ship.destination.name                            1  src/trade.py
#  self.model.ship.destination.name                            3  src/play.py
#  self.model.ship.empty_low_berths                            1  src/play.py
#  self.model.ship.empty_low_berths                            1  src/terminal.py
#  self.model.ship.empty_passenger_berths                      1  src/play.py
#  self.model.ship.empty_passenger_berths                      1  src/terminal.py
#  self.model.ship.encode()                                    1  src/play.py
#  self.model.ship.engineering_skill()                         1  src/jump.py
#  self.model.ship.free_space()                                1  src/play.py
#  self.model.ship.free_space()                                1  src/terminal.py
#  self.model.ship.free_space()                                2  src/trade.py
#  7  self.model.ship.fuel_quality                                1  src/play.py
#  self.model.ship.fuel_quality                                3  src/jump.py
#  self.model.ship.fuel_quality                                3  src/starport.py
#  self.model.ship.high_passenger_count                        1  src/play.py
#  8  self.model.ship.hold                                        1  src/menu.py
#  self.model.ship.hold                                        1  src/orbit.py
#  self.model.ship.hold                                        1  src/play.py
#  self.model.ship.hold                                        1  src/terminal.py
#  self.model.ship.hold                                        4  src/trade.py
#  self.model.ship.insufficent_jump_fuel_message()             1  src/jump.py
#  self.model.ship.insufficient_life_support_message()         1  src/jump.py
#  self.model.ship.life_support_level                          1  src/jump.py
#  self.model.ship.life_support_level                          1  src/play.py
#  self.model.ship.load_cargo()                                2  src/trade.py
#  6  self.model.ship.low_passenger_count                         1  src/menu.py
#  self.model.ship.low_passenger_count                         1  src/play.py
#  self.model.ship.low_passenger_count                         2  src/orbit.py
#  self.model.ship.low_passenger_count                         2  src/starport.py
#  self.model.ship.maintenance_cost()                          1  src/starport.py
#  self.model.ship.medic_skill()                               1  src/orbit.py
#  self.model.ship.middle_passenger_count                      1  src/play.py
#  self.model.ship.model.fuel_tank                             1  src/jump.py
#  self.model.ship.model.fuel_tank                             1  src/play.py
#  self.model.ship.model.jump_range                            1  src/jump.py
#  self.model.ship.model.jump_range                            1  src/menu.py
#  self.model.ship.model.jump_range                            1  src/terminal.py
#  self.model.ship.model.jump_range                            1  src/trade.py
#  self.model.ship.model.name                                  1  src/play.py
#  self.model.ship.model.streamlined                           1  src/jump.py
#  self.model.ship.model.streamlined                           1  src/orbit.py
#  self.model.ship.model.trip_fuel_cost                        1  src/play.py
#  self.model.ship.name                                        2  src/menu.py
#  self.model.ship.recharge()                                  1  src/starport.py
#  self.model.ship.refuel()                                    1  src/starport.py
#  self.model.ship.sufficient_jump_fuel()                      1  src/jump.py
#  self.model.ship.sufficient_life_support()                   1  src/jump.py
#  self.model.ship.total_passenger_count                       1  src/orbit.py
#  self.model.ship.total_passenger_count                       2  src/starport.py
#  self.model.ship.trade_skill()                               2  src/trade.py
#  self.model.ship.unrefined_jump_counter                      1  src/jump.py
#  self.model.ship.unrefined_jump_counter                      2  src/starport.py
#  self.model.ship.warn_if_not_contracted()                    1  src/jump.py
#
#  self.model.star_map                                         1+ src/menu.py
#  self.model.star_map.get_all_systems()                       1  src/play.py
#  self.model.star_map.get_subsector_string()                  2  src/play.py
#  6  self.model.star_map.get_system_at_coordinate()              1  src/menu.py
#  self.model.star_map.get_system_at_coordinate()              1  src/trade.py
#  self.model.star_map.get_system_at_coordinate()              3  src/jump.py
#  self.model.star_map.get_system_at_coordinate()              1  src/terminal.py
#  self.model.star_map.get_systems_in_subsector()              1  src/menu.py
#  self.model.star_map.get_systems_in_subsector()              1  src/play.py
#  self.model.star_map.get_systems_within_range()              1  src/jump.py
#  self.model.star_map.get_systems_within_range()              1  src/menu.py
#  self.model.star_map.list_map()                              1  src/play.py
#  5  self.model.star_map.subsectors                              2  src/menu.py
#  self.model.star_map.subsectors                              3  src/play.py
#  8  self.model.star_map.systems                                 1  src/jump.py
#  self.model.star_map.systems                                 3  src/play.py
#  self.model.star_map.systems                                 4  src/menu.py
#
#  The guard clauses in the command procedures seem like natural clumps.
#  They have different messages, and the Model shouldn't handle any
#  display or printing. Maybe inserting an observer here would help.
#
#  Another observation: the contents of the commands in the Screen classes
#  can probably be lifted directly over to Model, but there's both good
#  and bad there.
#
#  On the plus side, we can convert them to just return a string back to
#  the Screen, which makes these procedures testable finally. That's a big
#  win.
#
#  On the negative side, though, a few of these procedures are quite large
#  and ought to be broken down further. Arguably I could do that _after_
#  the move, but now is a good time to peel out at least a few pieces.
#
#  The other problem is the interface to Model is going to get very large.
#  Not sure yet where we'll go with that particular issue. Probably shift
#  a bunch of things to internals and/or private methods, and spin up
#  manager classes as needed. But the externally facing interface still
#  needs a lot of stuff, and I _do_ want to keep it within a single class
#  to minimize coupling from Screen. It's also possible I'll spot some
#  visible seams that provide a natural place to break Model into a small
#  (two or three) number of classes. We'll see.
#
#  Handled:
#
#  self.model.ship.repair_status                               2  src/orbit.py
#  self.model.ship.repair_status                               2  src/play.py
#  self.model.ship.repair_status                               4  src/starport.py
#  self.model.ship.repair_status                               6  src/jump.py
#  self.model.location.detail                                  1  src/terminal.py
#  self.model.location.detail                                  1  src/trade.py
#  self.model.location.detail                                  2  src/jump.py
#  self.model.location.detail                                  2  src/orbit.py
#  self.model.location.detail                                  3  src/menu.py
#  self.model.location.detail                                  3  src/starport.py
#  self.model.location.name                                    1  src/jump.py
#  self.model.location.name                                    1  src/play.py
#  self.model.location.name                                    1  src/terminal.py
#  self.model.location.name                                    1  src/trade.py
#  self.model.location.name                                    3  src/orbit.py
#  self.model.location.name                                    3  src/starport.py
#  self.model.ship.passengers                                  1  src/play.py
#  self.model.ship.passengers                                  1  src/starport.py
#  self.model.ship.passengers                                  2  src/menu.py
#  self.model.ship.passengers                                  3  src/orbit.py
#  self.model.ship.passengers                                  3  src/terminal.py
#  self.model.date.day                                         1  src/orbit.py
#  self.model.date.day                                         1  src/starport.py
#  self.model.date.day                                         3  src/jump.py
#  self.model.date.day                                         4  src/trade.py
#  self.model.location.starport                                8  src/starport.py
#
# -------------------------------------------------------------

~HERE~

# -------------------------------------------------------------
# ROADMAP
# Mulling over how to tackle ever-increasing TO_DO list.
# I think we can chunk the work into a few phases:
#  PHASE ONE
#  * Full feature set for in-system speculative trading. Just a few
#    maintenance costs left to go.
#  * Basic travel & resources features.
#  * Refactoring. In the midst of a big push right now.
#  * (Should really take my medicine and get tests/pylint/etc. done)
#  PHASE TWO
#  * Jumping to a new system and all it implies:
#    * Multiple systems
#    * Star map
#    * Coordinate system
#  PHASE THREE
#  * Adding freight & passengers
#  * Any other remaining RAW procedures:
#    * crew, misjumps, etc.
#  PHASE FOUR
#  * Handling technical debt:
#    * (We _should_ be doing some of this as we go, at least at the
#       end of each phase...)
#    * Test coverage
#    * Refactoring
#    * Best practices and 'pythonic' coding
#  PHASE FIVE
#  * Polishing game mechanisms:
#    * UI work
#    * Front end and menu
#    * Save/load if not done earlier
#    * Player customization: ship name, captain, etc.
#  PHASE SIX <== we are here
#  * Another refactoring push
#  PHASE SEVEN
#    * Expand scope with RPG-lite elements and events
#    * Lift into graphics system? (This could really snowball, be cautious)
#    * Explore later Traveller versions for ideas (or to support as options)
#    * Other game types, like Explorer? To the Stars? Pocket Empires?
# -------------------------------------------------------------

# --------------------------------------------------------------
# Consolidating TO_DO list:

#  PHASE ONE =======================================================
#  * [DONE] Create a currency class to keep value vs. display straight
#  * [DONE] Deprecate and remove credit_string() function
#  * [DONE] Add (basic) math/comparison operators to currency class
#            (add more operators as needed)
#  * [DONE] Change purchase/sale DMs from lists to hashes to improve data
#            entry and validation
#  * [DONE] Regenerate cargo for sale weekly (and reset price adjustment)
#  * [DONE] Review Calendar increment scenarios, remove speculative options
#  * [DONE] Add 'wait a week' command
#  * [DONE] Add extended berthing fee mechanism
#  * [DONE] Add monthly loan payment
#  * [DONE] Add monthly crew salaries
#  * [DONE] Protect input from bad data - one example, non-numeric
#            values cause crashes
#  * [DONE] Extract confirmation input loop to a reusable function
#  * [DONE] Display current date
#  * [DONE] Add fuel system to Ship
#  * [DONE] Add refuelling costs at starport
#  * [DONE] Restructure payment flow & dependencies for fuel
#  * [DONE] Add starport classification to StarSystem
#  * [DONE] Pass Credits in to Cargo ctor, not integer that needs conversion
#  * [DONE] Add fuel level check before executing jump
#  * [DONE] Add gas giant presence to StarSystem
#  * [DONE] Add view StarSystem data action
#  * [DONE] Skimming as jump point action, assuming gas giants present in 
#            StarSystem (abstract the outer system for this purpose)
#  * [DONE] Add 'plus days' method to ImperialDate (went with dunder again)
#  * [DONE] Create an unload_cargo method to consolidate proper handling
#  * [DONE] Add crew skills and their influence on sale prices
#  * [DONE] Add brokers and their influence on sale prices
#  * [DONE] Add display of ship characteristics
#  * [DONE] Prevent immediate resale of bought cargo
#            (current solution just prevents sale to source world, may want
#             to add a time element - simplest would be to reset the source_world
#             field to None, but later for Merchant Prince we may want to retain it)
#  * [DONE] Separate code out into modules
#  * [DONE] Review interpretation that skills/brokers only apply to sales - yes
#  * [DONE] Review Calendar.year() setter for whether it should notify observers - yes
#  * [DONE] Make StarSystem.__eq__ more robust
#  * [DONE] Add ship streamlining and effect upon landing/skimming
#  * [DONE] Add life support system to Ship
#  * [DONE] Add life support recharging costs
#  * [DONE] Check life support level before jump
#  * [DONE] Add fuel level check before travelling to jump point
#  * [DONE] Add life support expenditure
#  * [DONE] Add fuel expenditure
#  # [DONE] Unit tests for ImperialDate
#  # [DONE] Add test suite
#  # [DONE] Unit tests for Credits
#  * [DONE] Add maintenance availability to StarSystem (A + B starports)
#  # [DONE] Unit tests for Cargo
#  * [DONE] Add annual maintenance
#  # [DONE] Unit tests for Ship
#  # [DONE] Unit tests for Calendar
#  * [DONE] BUG: price array isn't updated when we remove Cargo from the Depot
#  # [DONE] Unit tests for Financials
#  # [DONE] Unit tests for StarSystem
#  * [DONE] Longer intervals need to make sure repeating events execute multiple times
#  # [DONE] Unit tests for utilities
#  # [DONE] Unit tests for CargoDepot
#  * [DONE] Advance calendar for in-system activities
#  * [DONE] Review need for fractional credits ('cents') - not needed
#  * [DONE] First pass pylint cleanup
#  PHASE TWO =======================================================
#  * [DONE] Basic StarMap class with coordinate & distance functionality
#  * [DONE] Add select destination before jump (will tie in to subsector map,
#            world generation, possibly freight & passenger selection)
#  * [DONE] Flesh out jump action sequence
#  * [DONE] Fix handling of observers after jump
#  * [DONE] BUG: Command messages not displaying correct world post-jump
#  * [DONE] Thoroughly test jump scenarios, verify location is changed everywhere
#  * [DONE] BUG: StarMap.get_systems_within_range is returning only systems AT range
#  * [DONE] Set starting location to StarMap origin point
#  * [DONE] Move Command message into game methods
#  * [DONE] Examine observers post-jump (depot especially) to verify correctness
#  * [DONE] BUG: maintenance date discrepancy between Financials & Ship
#  * [DONE] BUG: possible to be at jump point with zero fuel, and travel inbound to -5 fuel
#  * [DONE] Color initial command message string to make it stand out
#  * [DONE] Validate coordinates in StarMap ctor before building dictionary
#           (is this YAGNI? think we will need if we have manual input of star map data)
#  * [DONE] BUG: inbound fuel check too strict, can't travel in post-jump
#           (fixed - but should we do the same for outbound? as long as there is
#            a gas giant it would be fine, but otherwise player can get stranded
#            potentially...)
#  * [DONE] Calculate three-axis coordinates surrounding an origin hex at given range
#  * [DONE] Implement JIT world generation to populate an 'infinite' map
#  * [DONE] World strings should include coordinates
#  * [DONE] Verify map persistence
#  * [DONE] Add command to list out the star_map
#  * [DONE] Create a StarSystemFactory (we still want to be able to directly
#           create a world via params, so don't want this in the ctor)
#  * [DONE] Handle UWP formatting issue with 'hex' codes. Should we have a class?
#  * [DONE] Write up a manual test script
#  PHASE THREE =====================================================
#  * [DONE] No fuel should be available at E & X starports
#  * [DONE] Generate new star systems when jumping in, rather than
#           when jumping out as in current implementation
#  * [DONE] Assess whether a '2d6' method, or variable number of dice, is useful
#  * [DONE] Add Freight class
#  * [DONE] Unit tests for Freight
#  * [DONE] Add a destination flag to the Ship as aid for freight/passenger procedures
#  * [DONE] Only show matching destination when re-entering load_freight() if freight
#           already loaded
#  * [DONE] Finish unload_freight() method
#  * [DONE] Issue warning if jump destination does not match Ship.destination
#  * [CUT ] Should we automatically exit freight loop if none left will fit in hold?
#  * [CUT ] Should we allow putting freight back?
#  * [DONE] Freight should be blocked (or better, filtered) when selling cargo
#  * [DONE] Test sell_cargo() filtering with discontinuous list
#  * [DONE] load_freight() corner case: running on destination world before offloading,
#           so flag is still set
#  * [DONE] unload_freight() corner case: destination set but no freight on board
#  * [CUT ] unload_freight() corner case: freight for different destination on board
#  * [CUT ] unload_freight() corner case: freight for multiple destinations on board
#  * [CUT ] multiple destinations is tricky... in that case, what should the field
#           be set to? And if you offload one set, how does the field look afterwards?
#           But we ruled this out earlier, right? Implicit expiration date on shipping?
#  * [DONE] load_freight() corner case: 0 tons freight selected
#  * [DONE] sell_cargo() corner case: trying to sell with empty hold (or just Freight)
#  * [DONE] BUG: when overriding freight destination list due to flag, a non-reachable
#           world can be selected. Need an intersection between flag and list instead.
#  * [DONE] Add __hash__ dunder to StarSystem to allow placement in sets
#  * [DONE] Consider making the destination flag a dynamic query property instead, based
#           on contents of hold/passenger compartment
#  * [DONE] Add unit tests for Ship.destination property
#  * [DONE] Hide all StarSystem() ctor calls behind StarSystemFactory
#  * [DONE] Move destinations into StarSystem class
#  * [DONE] Should populate the map for the starting world at launch. Currently
#           hasn't mattered due to jump-1 ship we're testing, but change to
#           jump-2 and observe that neighbors aren't generated until the
#           jump command is issued.
#  * [DONE] Refactoring suggestion: we call get_systems_within_range() twice in Game.jump(),
#           once for (hopefully) pre-existing data, and once for the side effect of
#           populating StarMap.systems. Split this up.
#  * [DONE] Freight list per-destination should persist
#  * [DONE] Freight list per-destination should be refreshed weekly
#  * [DONE] Add freight shipping
#  * [DONE] Add passenger terminal: location, transition commands, command set
#  * [DONE] Add Passenger enum
#  * [DONE] Add refresh_passengers() and CargoDepot.passengers field
#  * [DONE] Add get_available_passengers()
#  * [DONE] Add book_passengers()
#  * [DONE] Add passenger manifest
#  * [DONE] Add Passenger class
#  * [DONE] Adjust destination property in Ship once we have passengers
#  * [DONE] Only show matching destination for freight if passengers already picked (destination
#           property ought to take care of this, check)
#  * [DONE] Disembark passengers when landing at destination
#  * [CUT ] Should we make contracted destination visible? Or is it apparent from
#           cargo hold and passenger manifest data? (Yeah, that's good enough for now...)
#  * [DONE] Reset destination flag when all freight & passengers offloaded (should
#           be handled automatically by destination property. Verify!)
#  * [DONE] Add passengers
#  * [DONE] BUG: if player selects freight (and passengers?) then does not confirm the
#           transaction, the items are still removed from the available freight list
#           (Passengers uses a tuple, which copies by value, not reference, so it is OK)
#  * [DONE] Truth table out the logic for combinations of cargo/freight/passengers/destination
#  * [DONE] Consider asserts for constraint violations in freight logic especially. Should
#           not have a None flag if there is freight in the hold, and should not allow
#           freight for multiple destinations in the hold. (Property may take care of this
#           now. Verify!)
#  * [DONE] Review book_passengers() for behavior when passengers are already on board - 
#           should only be possible for same destination
#  * [DONE] Add survival odds for low berth passengers, and report results each trip
#  * [DONE] Add passenger endurance (affects low berth survival)
#  * [DONE] Add low berth lottery
#  * [DONE] Add medic skill to Ship and hook into low berth survival
#  * [DONE] Add crew members with individual skills
#  * [DONE] Add proper salary calculation per crew member, including seniority/skill
#  * [DONE] Add crew roster command
#  * [DONE] BUG: was able to keep adding middle passengers after filling ship with high
#           passengers, and arrived at -6 staterooms. On testing, seems to be when
#           re-entering book_passengers() on same or different world. Ah. See it.
#           We set up the method with stateroom count, not _empty_ stateroom count...
#  * [DONE] Passenger baggage allowance. From the hold or included in stateroom size?
#  * [DONE] Add unrefined fuel
#  * [DONE] Add urefined fuel message to ship details command
#  * [DONE] Unrefined fuel status should clear when tanks are emptied - currently
#           handling via logic in refuel. This might need a property around current_fuel field
#  * [DONE] Add 'flush tanks' command to conform to Traveller '77 RAW procedures.
#  * [DONE] Add unrefined fuel jump counter
#  * [DONE] Add chance for drive failure from unrefined fuel during jump
#  * [DONE] Add ship repair status, display it too
#  * [DONE] Add chance for drive failure from skipped maintenance
#  * [DONE] Restrict ship movement based on repair status
#  * [DONE] Add repair action for engineer in flight
#  * [DONE] Add repair action at starport
#  * [DONE] Add null system class and replace None references
#  * [DONE] Add check for misjump and effects of same
#  * [DONE] Add a word generator module, with a get_name() function
#  * [DONE] Generate world names
#  * [DONE] Add a basic word list
#  PHASE FOUR ======================================================
#  * [DONE] Consider moving tests to separate modules
#  * [DONE] pylint/pydocstyle scrub (not quite 100%, but very close, clean up remainder
#           as we continue refactoring)
#  * [DONE] BUG: unable to load freight that exactly fits in the hold (free_space == 0)
#  * [DONE] BUG: able to add high passengers even when no room in hold for baggage
#           resulting in negative free space
#  * [DONE] Move cargo data to separate data file
#  * [DONE] Review uses of die_roll and replace with multiple die functionality as necessary
#  * [DONE] Introduce a UWP class
#  * [DONE] Properly mark base classes as ABC
#  * [DONE] Review (and possibly deprecate) item_number return value from CargoDepot.get_cargo_lot()
#  * [DONE] BUG: misjumped to a distant system and it did not appear in the
#           'view all systems' list
#  * [DONE] Lift all print statements out of model classes
#           (this might resolve the skipped tests - if not, that's a separate TO_DO)
#  * [DONE] BUG: Sale/purchase price lines are not always printing - haven't pinned
#           down conditions yet. Ah! Need to wire up the observer again post-jump!
#  * [DONE] Lift all input statements out of model classes
#  * [DONE] Should we add type annotations? (Possibly check out mypy...)
#  * [DONE] Create a linter script to run all quality checks
#  * [DONE] Get 100% clean on pylint/pydocstyle/mypy/unittests
#  PHASE FIVE ======================================================
#  * [DONE] Can we colorize current location in star map listing?
#  * [CUT ] Add a 'shore leave' action? (Is this different from 'wait'? How?)
#  * [DONE] Should/could we clear the screen?
#  * [DONE] Passenger selection interface is really tedious. Need some way to enter numbers
#           instead of choosing one at a time.
#  * [DONE] BUG: single token input in _select_passengers() crashes game:w
#  * [DONE] Timing of sleep() after each command doesn't feel right - either too long
#           for immediate commands, or too short for view commands. Change design.
#  * [DONE] New game
#  * [DONE] Front end menu
#  * [DONE] Implement coordinate conversion to Traveller subsector row/column
#  * [DONE] State enum is redundant - can just use Screen subclasses directly
#  * [DONE] Should Coordinate be a class or can it remain a type?
#  * [DONE] Break up Game class (MVC?)
#  * [DONE] BUG: save game and sell cargo use the same command key
#  * [DONE] BUG: game crashes when selling cargo post-jump
#  * [DONE] Move detail from StarSystem into Screen hierarchy
#  * [DONE] Merge screens/menus and location state transitions?
#  * [DONE] Add subsectors
#  * [DONE] Coordinate conversion needs to handle subsector/sector bounds
#  * [CUT ] Storing/retrieval of StarSystem from StarMap - should this involve Subsector?
#  * [DONE] Add a much larger list for world names, and add variation like
#           "New" or "Station"
#  * [DONE] Subsector naming
#  * [DONE] BUG: berthing fee is not being applied when landing on a world
#  * [DONE] Encode/decode UWP as/from a string
#  * [DONE] Encode/decode Coordinate as/from a string
#  * [DONE] We allow invalid 3-axis data into the Coordinate ctor because
#           StarMap._get_all_coords() needs that ability. But does this prevent
#           us from trapping bad data in the save file?
#  * [DONE] Encode/decode StarSystem as/from a string
#  * [DONE] Encode/decode DeepSpace as/from a string
#  * [DONE] Save/load subsector data
#  * [DONE] After switching to json.dump, terminal newline may not be necessary - review
#  * [DONE] BUG: load game doesn't allow naming of the ship
#  * [DONE] BUG: load game crashes if save_game file doesn't exist
#  * [DONE] Save game should not overwrite previous saves
#  * [DONE] Load game should allow selection of save files
#  * [DONE] Save/load current date
#  * [DONE] Move data files to a subdirectory
#  * [DONE] Add a transaction ledger to Financial class
#           Will want to play around with it to determine format & functionality,
#           for now just store a simple list of strings
#  * [DONE] Add a 'view ledger' command
#  * [DONE] Ledger should just print world name, not full string
#  * [DONE] Reformat ledger to align columns, and use two-column accounting
#  * [DONE] Track down all credit/debit calls and add memo strings
#  * [DONE] Encode/decode Passenger as/from a string
#  * [CUT ] Rework destinations to store just a Coordinate in Passenger/Freight/Baggage
#  * [DONE] Review remaining Passenger data: endurance, guess, survived
#           Need to save?
#  * [DONE] Encode/decode Freight as/from a (parsed) string
#  * [DONE] Encode/decode Baggage as/from a (parsed) string
#  * [DONE] Encode/decode Cargo as/from a (parsed) string
#  * [DONE] Composite from_string function to process cargo hold contents
#  * [DONE] Trap mixed destinations between Freight/Passengers in save & load
#  * [DONE] Encode/decode Ship as/from a string
#  * [DONE] BUG: load game file list is unordered
#  * [DONE] Encode/decode Financials as/from a string
#  * [DONE] Encode/decode financials ledger in save_file
#  * [DONE] Capture current location in save file
#  * [DONE] Save game state (ship, finances, date, map, location)
#  * [DONE] Load game state (ship, finances, date, map, location)
#  * [DONE] Separate out static ship data into a 'ship model' class and compose
#  * [DONE] 'Select ship' option in new game - could add the Type-S Scout
#  * [DONE] Ships with better than jump-1 should be able to choose short jumps too.
#  * [DONE] Handle varying Crew positions in different ShipModels
#  * [DONE] Load ship model data from a file
#  * [DONE] BUG: player can enter a blank ship name in new_game
#  * [DONE] linter calls in lint.sh are not recursive and are not covering package sub-dirs
#  * [DONE] 'Dump ledger' command to export a readable version?
#  * [DONE] Export star map (this is different from save game how, exactly?
#           Probably puts subsector names & 2-axis coords for one thing...)
#  * [DONE] Move hard-coded start conditions out of Game ctor into some sort of default save file
#  * [DONE] Scrub for static-only classes and convert to modules if necessary
#  * [DONE] DESIGN ISSUE: single-letter commands are becoming too restrictive    
#  * [DONE] Conversion of Traveller coordinates to 3-axis, probably needed to import
#           existing data
#  * [DONE] Add import of Traveller map data
#  * [DONE] UI Pattern: Choice. Have this in multiple places. Use as refactor target.
#  * [DONE] Integrate drawing module into game
#  * [DONE] Generate a bitmap StarMap
#  * [DONE] Pipe selected map data into drawing module
#           Alternatively, auto-generate multiple images, one per subsector in data?
#  * [DONE] Adjust map graphics per map data
#  * [DONE] Tweak asteroid belt graphic in draw_map module - fully random approach
#           can generate some ugly icons
#  * [DONE] Handle map image file, overwrite, naming, etc.
#  * [DONE] Add alternate color schemes, like printable/light. Customizeable?
#  * [DONE] Add start location to import file
#  * [DONE] Trap invalid start location when importing
#  PHASE SIX ======================================================
#  * [DONE] Break up modules
#  * [DONE] Rename Passengers screen class to Terminal
#  * [DONE] Consolidate mock objects into mock module
#  * [DONE] Rework how crew skills are handled
#  * [DONE] BUG: Scout only has a Pilot on board, fails with "no Engineer" when
#           attempting damage control
#  * [DONE] Fix mypy errors with Pillow (nix-shell -p python311Packages.types-pillow)
#  * [DONE] Timing of remaining passengers listing isn't quite right in _select_passengers()
#  * [DONE] Should screen classes carry that suffix for clarity? (i.e. TerminalScreen)
#  * [DONE] Add cyclomatic complexity to lint criteria, and deal with warnings
#  * [DONE] Review all classmethods, replace with simple functions if applicable
#  * [DONE] Properly separate __repr__ and __str__ for all classes
#           Note that __repr__ should be recursive for arg objects
#  * [DONE] Add a 'Model' class and move references from Game to it
#  * [....] Adjust UI elements, play with more ANSI codes - also review color
#           coding for warnings, positive/negative messages, etc.
#  * [....] Extract all the three-axis coordinate math to its own class
#  * [....] Refactor freight/passenger methods, push down pieces as appropriate
#  * [....] Make type dunder methods more robust with NotImplemented etc.
#  * [....] Extend payment flow model to reduce coupling between classes
#  * [....] Review and mark or export private/public members
#  * [....] Look for multiline message_observer() usage - may need to adjust
#           ObserverMock to retain all messages in a queue, currently only holds last one
#  * [....] Review test fixtures for mock opportunities
#  * [    ] Review confirm blocks, inconsistent usage throughout
#  * [    ] BUG: maintenance date warning prints twice
#  * [    ] Deal with non-portable font in drawing module
#  * [    ] Experiment with layout values in drawing module, can we support resizing?
#  * [    ] BUG: import can't handle spaces in world name (e.g. Regina 0604 Beck's World)
#  * [    ] Remove Ship & Location from Financials ctor arguments? We are bypassing
#           and assuming they get attached later for the load_game() case. Should this
#           always be assumed? If so should trap malformed - don't like ctor
#           leaving object in a partially-constructed state.
#  * [    ] Handle save/load exceptions in app rather than crashing out
#  * [    ] Should the dump_*() methods allow player to name output file? Or have
#           a auto-increment scheme like save files?
#  * [    ] With new src & test packages, unable to directly run test files - need
#           to run via unit_tests.py. Removing __main__ check consequently, research
#           better alternatives.
#  * [    ] Review lifespan of Subsector. Currently we only create them when generating
#           pretty_coordinates() for a StarSystem. Should probably do this earlier -
#           when creating the StarSystem itself?
#  * [    ] Handling of load game list when there are no save files could be smoother
#  * [    ] Small amount transactions can lead to a long balance string in MCr,
#           which throws off column alignment in ledger - restrict decimal places in Credits?
#  * [    ] Trap out-of-range subsector coords - where/when?
#  * [    ] Is Subsector class redundant? Should kill?
#  * [    ] Review flow, confirmations, notifications - streamline where annoying,
#           slow down where mistakes happen
#  * [    ] Rather than having up-front tests, make some commands dynamically
#           available in command lists when conditions merit - e.g. only present
#           skimming as jump point command if the system has a gas giant
#           Handle this in Play.update() - each state should have a method to
#           add/remove commands dynamically, call it on transition
#  * [    ] Per Beck's 'prefer symmetry,' instead of foo_from() and Foo.encode(),
#           maybe we should have either decode_foo() and Foo.encode() or
#           foo_from() and Foo.to()...
#  * [    ] Similar symmetry concerns with menu/state and location.detail (see load_game())
#  * [    ] Also standardize interface, some classes 'encode' with __str__. Possibly
#           uniform encode() protocol everywhere, which can always just wrap __str__
#           in the simple cases.
#  * [    ] Should we formalize message priority as an enum or something?
#  * [    ] Should get_input() live in screen/controller classes?
#  * [    ] Should on_notify() live in screen/controller classes?
#  * [    ] Could a decorator handle the little pause at the end of view commands?
#  * [    ] Add a mixin Observer class to manage the interface? Or at the 'observed'
#           end? We may be specializing/overriding on_notify()...
#  * [    ] Review unittest.Mock/MagicMock - should replace homegrown?
#  * [    ] Learn how to use mock.patch to deal w/ side effect testing (stackoverflow 21046717)
#  * [    ] Apply mock.patch or monkeypatch to die_roll() so we can have
#           deterministic tests
#  * [    ] Review world string UWP for errors, do we need an e-hex function?
#  * [    ] Extract text strings
#  * [    ] Some payments don't check bank balance first - scrub & fix!
#  * [    ] Review overlap of CargoDepot.remove_cargo() and Ship.unload_cargo()
#  * [    ] Now that we have file operations, need to properly trap errors (FileNotFound etc.)
#  * [    ] Catch up test coverage, both for known/fixed bugs and methods & code paths
#  * [    ] Assess need to unset berth recurrence/expiry on takeoff
#  * [    ] Review observer tests for boundary values and long intervals
#  * [    ] Restrict Passenger.guess_survivors() to low passengers only
#  * [    ] Consider merging Baggage into Freight - class isn't pulling its weight
#  * [    ] Replace ValueError and other 'generic' exceptions with custom
#  * [    ] Refactoring suggestion: have Ship own Financials (or other way around?)
#  * [    ] Refactoring suggestion: inbound/outbound methods in Game are almost
#           identical, and should be merged (consider fuel cost warning & stranding)
#           (Add another warning if fuel at 'stranding level' and no gas giant?)
#  * [    ] Review applicability of dataclasses/namedtuples (stackoverflow 47955263)
#  * [    ] Collapse Crew hierarchy?
#  * [    ] Sort out confusion in Hex hierarchy type annotation
#  * [    ] Eliminate unnecessary pylint disable statements (currently 35 in test and
#           17 in src)
#  * [    ] Assess whether rounding in Credits ctor can cause errors
#  * [    ] Review redundancy between Calendar.day() and ImperialDate ctor
#  * [    ] Fix ImperialDate ctor logic for increments larger than one year
#  * [    ] Shotgun surgery between starting commands and star system detail setting
#  PHASE SEVEN ====================================================
#  * [    ] Consider alternate image layouts: 'circle map', or not bound to subsector edges
#  * [    ] We have our first unstreamlined ship (Type Y Yacht) - it can't refuel
#           as it can't land or skim, and can't recharge life support either. We need
#           a highport location and/or shuttle refuelling to make this usable.
#  * [    ] Add customization of crew members, names, etc.
#  * [    ] Add support for Bases, Travel Zones, Xboat Routes and Allegiance in import data
#  * [    ] DESIGN ISSUE: player can cancel and retry sale to get a better price
#  * [    ] 'Plot a route' functionality? Plan out a sequence of jumps?
#  * [    ] A world with: no gas giants, no hydrosphere, and starport E/X has
#           no fuelling options and is dangerous to travel to for normal 
#           commercial ships. Should flag this somehow. Mark red in listing?
#  * [    ] Should we track cargo details in ledger? Would be good to help the player
#           analyze performance
#  * [    ] The ledger could get very long. Will want to manage in the view. Simplest
#           is to show just last n lines. Better still would be some kind of scrolling
#           functionality.
#  * [    ] Investigate __format__ for ImperialDate so we can tab-align ledger columns
#  * [    ] End game condition? In my recent test run, I arrived at an E-starport
#           world with no gas giant. It has a hydrosphere, but I haven't 
#           implemented wilderness refuelling yet. So my ship is stuck. Game Over?
#           Or add iceteroid mining as an extreme (and very lengthy) procedure?
#  * [    ] Other end-game conditions: misjump to deep space, travel in to an E/X
#           world without refelling from gas giant...
#  * [    ] Add Navy/Scout bases to StarSystem? Only for color, yes?
#  * [    ] Restrict life support recharge at low-facility starports?
#  * [    ] Should life support percentage be tied to 'days duration?' But what
#           happens if it hits zero?
#  * [    ] Set a 'visited' flag on StarSystem when jumping in? Might be needed
#           for perf as discussed above, but even if not I could see map displays
#           making use of it. Sort of a Fog of War mechanic. This may be as
#           simple as whether StarSystem.destinations is populated or not.
#  * [    ] Add visualization of cargo purchase DMs (colorized trade codes?)
#           (should be able to view in hold and while trading,
#            possibly also while choosing a destination world)
#  * [    ] Traveller '77 had route determination. Add this?
#  * [    ] Should freight expire or be assessed a penalty fee for late delivery?
#           Similar question for passengers. Particularly meaningful in the case
#           of misjumps.
#  * [    ] Review starport services, like life support recharge. Seems it
#           should be restricted like fuel is. None available at E/X?
#           Similarly, should a berthing fee be charged if there is no berth?
#           How about cargo, freight and passengers? Later Traveller editions
#           labelled almost all X starports as Red Zones (doesn't exist in '77).
#           E is not much better. No good reason for a commercial starship to
#           go there (though PCs are expected to be more adventurous of course).
#  * [    ] In the same vein, doesn't make sense to charge a berthing fee at E/X starports
#  * [    ] Think about guard rails. We don't want to go overboard. Learning
#           which choices are wise and which are foolhardy is part of the game. So
#           refuelling availability, low-grade starports, getting stranded - let the
#           player do that! Question is what happens then? Game over conditions,
#           penalties that let them keep going?
#  * [    ] Maintenance assists, plotting routes to service centers
#  * [    ] Should we allow partial fuel fillup?
#  * [    ] Add out-of-funds condition (game over?) (Block in Financials?
#           i.e. balance can't go negative?)
#  * [    ] Expand options available in New Game - could expose all sorts of options
#           here like adjusting world creation parameters, but initially just
#           customizing ship and crew
#  * [    ] Would be nice to warp or randomly color UI if the ship is BROKEN...
#  * [    ] Ocean refuelling option if hydrographics permit it (should we then
#           split out another surface location? Implication of current 'surface' location
#           is it is the starport, which this is not. Scope creep, maybe hold this one
#           until phase five...
#  * [    ] Add extended StarSystem details
#  * [    ] Controls now allows us to have an AI or kiosk mode...
#  * [    ] Working passage?
#  * [    ] Should we allow the option of 'close jump?'
#  * [    ] A player _could_ purchase unrefined fuel at A/B starports to save money.
#           Should we allow that? Makes more sense if we add fuel purification to the game...
#  * [    ] Add mail? Usualy tied to Subsidised Merchants, which have a fixed route, so
#           not sure about this one.
#  * [    ] Review need for negative or zero credits (balances and debts?)
#           Defer - currently all uses are positive, even debts, but haven't
#           implemented a ledger or more accounting features yet
#  * [    ] Add loan history and statement (amortization schedule too?)
#  * [    ] Distinguish between highport and downport
#  * [    ] Replace dummy/test data with 'real' values
#  * [    ] Need to be able to see maintenance date
#  * [    ] Should we have a 'stranded' condition? Pay for a tow truck?
#  * [    ] List star map to take a range parameter? What's the use case?
#           Might be necessary if the list gets very large. Tests so far haven't had
#           more than a dozen or so worlds, but especially if we allow imported maps
#           this will be unwieldy.
#           Could have a couple modes: a basic 'view all systems within 6 parsecs' and
#           another that allows choosing a subsector by name and displaying its contents.
#           Now that we support importing data, the list has has hit this limit - should
#           rework.
#  * [    ] Add shuttles to surface (esp. for unstreamlined ships)
#  * [    ] Need to handle passengers if ship is unstreamlined
#  * [    ] Add ship design mode - ship customization and/or building from scratch
#  * [    ] RPG lite elements: named crew, brokers, color events & encounters, etc.
#  * [    ] Color: jump dimming
#  * [    ] If we want to expand beyond just the trade model, add 
#            ship encounters (Book 2 p. 36), hijacking, piracy, etc.
#  * [    ] Subsector summary data, like 'highest population is...'. See published
#           map data for examples.
#  BEYOND ==========================================================
#  * [    ] Alternate shells: GUI, 'Oregon Trail style', etc. Would be amusing to
#            do ASCII graphics...
#  * [    ] What about browser-based UI?
#  * [    ] Non-canon variations and features - draw from other RPGs, board games,
#           videogames, and brainstorming
#  * [    ] Other game modes, like Scouts - take a longer-range ship and explore.
#           Tweak world generation to produce frontier locations.
#  * [    ] Or cheats, like infinite money, free fuel, etc. (And actually a lot
#           of cheats start life as aids for testing. Might want a few of these to
#           help out as the game gets bigger.)
